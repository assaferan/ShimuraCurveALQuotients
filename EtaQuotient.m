declare type RngEtaQuot[EtaQuot];

declare attributes RngEtaQuot : M, ds, nor_eta_ds, prec, disc, BaseRing;

declare attributes EtaQuot : parent, coeffs, eta_quots, qexp_oo, prec_oo, qexp_0, prec_0;

intrinsic EtaQuotientsRing(M::RngIntElt, disc::RngIntElt) -> RngEtaQuot
{The ring of integral linear combinations of eta quotients generated by eta(d*t) for d dividing M and a lattice L of discriminant disc.}
    R := New(RngEtaQuot);
    R`M := M;
    R`ds := Divisors(M);
    R`BaseRing := Integers();
    R`prec := -1;
    R`disc := disc;
    R`nor_eta_ds := [];
    return R;
end intrinsic;

intrinsic BaseRing(R::RngEtaQuot) -> RngEtaQuot
{.}
    return R`BaseRing;
end intrinsic;

intrinsic Precision(R::RngEtaQuot) -> RngIntElt
{.}
    return R`prec;
end intrinsic;

intrinsic EtaQuotient(exps::SeqEnum[RngIntElt], M::RngIntElt, disc::RngIntElt) -> EtaQuot
{Return the eta quotient \prod eta(d*t)^exps[i] where d is the i-th element of Divisors(M)}
    R := EtaQuotientsRing(M, disc);
    eta := New(EtaQuot);
    eta`parent := R;
    eta`coeffs := [1];
    eta`eta_quots := [exps];
    return eta;
end intrinsic;

intrinsic EtaQuotient(R::RngEtaQuot, exps::SeqEnum[RngIntElt]) -> EtaQuot
{Return the eta quotient \prod eta(d*t)^exps[i] where d is the i-th element of Divisors(M)}
    eta := New(EtaQuot);
    eta`parent := R;
    eta`coeffs := [1];
    eta`eta_quots := [exps];
    // If this is a constant we create the precise q-expansions
    if &and[exp eq 0 : exp in exps] then
        Zq<q> := LaurentSeriesRing(Integers());
        eta`qexp_oo := Zq!1;
        eta`prec_oo := Infinity();
        eta`qexp_0 := Zq!1;
        eta`prec_0 := Infinity();
    end if;
    return eta;
end intrinsic;

intrinsic Parent(eta::EtaQuot) -> RngEtaQuot
{.}
    return eta`parent;
end intrinsic;

procedure update_precision_eta(~nor_eta_ds, Prec, ds)
    _<q> := LaurentSeriesRing(Integers());
    nor_eta := &*[1 - q^n : n in [1..Prec-1]] + O(q^(Prec));
    // eta_ds := [Evaluate(nor_eta, q^d)*q^(d/24) : d in Divisors(M)];
    nor_eta_ds := [Evaluate(nor_eta, q^d) + O(q^Prec) : d in ds];
    return;
end procedure;

procedure reduce(eta)
    non_zero_coeffs := [i : i->c in eta`coeffs | c ne 0];
    eta`coeffs := [eta`coeffs[i] : i in non_zero_coeffs];
    eta`eta_quots := [eta`eta_quots[i] : i in non_zero_coeffs];
    return;
end procedure;

function valuation_at_oo_lb(eta)
    R := Parent(eta);
    reduce(eta);
    if IsEmpty(eta`coeffs) then return Infinity(); end if;
    valuation_shifts := [&+[d*r[i] : i->d in R`ds] div 24 : r in eta`eta_quots];
    return Minimum(valuation_shifts);
end function;

intrinsic qExpansionAtoo(eta::EtaQuot, Prec::RngIntElt) -> RngSerLaurElt
{The q-expansion of eta at oo.}
    R := Parent(eta);
    
    if assigned eta`qexp_oo and Prec le eta`prec_oo then
         _<q> := Universe(R`nor_eta_ds);
        return eta`qexp_oo + O(q^Prec);
    end if;

    reduce(eta);

    if IsEmpty(eta`coeffs) then 
        Zq<q> := LaurentSeriesRing(Integers());
        eta`qexp_oo := Zq!0;
        eta`prec_oo := Infinity();
        return eta`qexp_oo + O(q^Prec);
    end if;

    valuation_shifts := [&+[d*r[i] : i->d in R`ds] div 24 : r in eta`eta_quots];
    prec_shift := Minimum(valuation_shifts);
    prec := Prec - prec_shift;

    if prec gt Precision(R) then 
        // curious - we are able to update something that does not exist ?
        update_precision_eta(~R`nor_eta_ds, prec, R`ds);
        R`prec := prec;
    end if;

     _<q> := Universe(R`nor_eta_ds);
    prod_nor_etas := [&*[(R`nor_eta_ds[i] + O(q^(Prec-prec_shift)))^r[i] : i->d in R`ds] : r in eta`eta_quots];
    prod_etas := [prod_nor_etas[j] * q^valuation_shifts[j] : j->r in eta`eta_quots];

    eta`qexp_oo := &+[c*prod_etas[j] : j->c in eta`coeffs];
    eta`prec_oo := Prec;

    return eta`qexp_oo + O(q^Prec);
end intrinsic;

intrinsic SAction(eta::EtaQuot : Admissible := true) -> EtaQuot
{Returns (f | S)(q^M) as in [GY, Lemma 26].}
    R := Parent(eta);
    S_eta := New(EtaQuot);
    S_eta`parent := R;
    reduce(eta);
    sqr_factors := [&*[d^r[i] : i->d in R`ds] : r in eta`eta_quots];
    if Admissible then sqr_factors := [sqr_fac*R`disc : sqr_fac in sqr_factors]; end if;
    scales := [];
    for sqr_factor in sqr_factors do
        is_sqr, scale := IsSquare(sqr_factor);
        assert is_sqr;
        Append(~scales, scale);
    end for;
    S_eta`coeffs := [c / scales[j] : j->c in eta`coeffs];
    S_eta`eta_quots := [Reverse(eta_quot) : eta_quot in eta`eta_quots];
    if Admissible then return R`M*S_eta; end if;
    return S_eta;
end intrinsic;

// This is Lemma 26 - q-expansion at 0 (multiplied by M if admissible)
intrinsic qExpansionAt0(eta::EtaQuot, Prec::RngIntElt : Admissible := true) -> RngSerLaurElt
{The q-expansion of eta at 0.}
    R := Parent(eta);
    if assigned eta`qexp_0 and Prec le eta`prec_0 then
         _<q> := Universe(R`nor_eta_ds);
        return eta`qexp_0 + O(q^Prec);
    end if;
    eta`qexp_0 := qExpansionAtoo(SAction(eta : Admissible := Admissible), Prec);
    eta`prec_0 := Prec;
    return eta`qexp_0;
end intrinsic;

intrinsic Print(eta::EtaQuot)
{.}
    val_lb := valuation_at_oo_lb(eta);
    default_prec := 12;
    printf "%o", qExpansionAtoo(eta, default_prec + val_lb);
end intrinsic;

intrinsic Print(R::RngEtaQuot)
{.}
    printf "Ring of eta quotients of level %o.", R`M;
end intrinsic;

intrinsic Coefficients(eta::EtaQuot) -> SeqEnum[RngIntElt]
{.}
    return eta`coeffs;
end intrinsic;

intrinsic Exponents(eta::EtaQuot) -> SeqEnum[SeqEnum[RngIntElt]]
{.}
    return eta`eta_quots;
end intrinsic;

// Arithmetic
intrinsic '+'(eta1::EtaQuot, eta2::EtaQuot) -> EtaQuot
{.}
    R := Parent(eta1);
    require R eq Parent(eta2) : "Eta quotients must belong to the same ring.";

    eta := New(EtaQuot);
    eta`parent := Type(BaseRing(Parent(eta2))) eq FldRat select Parent(eta2) else R;
    eta`coeffs := eta1`coeffs cat eta2`coeffs;
    eta`eta_quots := eta1`eta_quots cat eta2`eta_quots;

    reduce(eta);

    if assigned eta1`qexp_oo and assigned eta2`qexp_oo then
        eta`qexp_oo := eta1`qexp_oo + eta2`qexp_oo;
        eta`prec_oo := Minimum(eta1`prec_oo, eta2`prec_oo);
    end if;

    if assigned eta1`qexp_0 and assigned eta2`qexp_0 then
        eta`qexp_0 := eta1`qexp_0 + eta2`qexp_0;
        eta`prec_0 := Minimum(eta1`prec_0, eta2`prec_0);
    end if;

    return eta;
end intrinsic;

intrinsic '*'(a::RngIntElt, eta::EtaQuot) -> EtaQuot
{.}
    eta_a := New(EtaQuot);
    eta_a`parent := Parent(eta);
    eta_a`coeffs := [a*c : c in eta`coeffs];
    eta_a`eta_quots := eta`eta_quots;

    reduce(eta_a);

    if assigned eta`qexp_oo then
        eta_a`qexp_oo := a*eta`qexp_oo;
        eta_a`prec_oo := eta`prec_oo;
    end if;

    if assigned eta`qexp_0 then
        eta_a`qexp_0 := a*eta`qexp_0;
        eta_a`prec_0 := eta`prec_0;
    end if;

    return eta_a;
end intrinsic;

intrinsic '*'(a::FldRatElt, eta::EtaQuot) -> EtaQuot
{.}
    eta_a := New(EtaQuot);
    eta_a`parent := Parent(eta);
    eta_a`parent`BaseRing := Rationals();
    eta_a`coeffs := [a*c : c in eta`coeffs];
    eta_a`eta_quots := eta`eta_quots;

    reduce(eta_a);

    if assigned eta`qexp_oo then
        eta_a`qexp_oo := a*eta`qexp_oo;
        eta_a`prec_oo := eta`prec_oo;
    end if;

    if assigned eta`qexp_0 then
        eta_a`qexp_0 := a*eta`qexp_0;
        eta_a`prec_0 := eta`prec_0;
    end if;

    return eta_a;
end intrinsic;

intrinsic '-'(eta1::EtaQuot, eta2::EtaQuot) -> EtaQuot
{.} 
    return eta1 + (-1)*eta2;
end intrinsic;

intrinsic 'eq'(R1::RngEtaQuot, R2::RngEtaQuot) -> BoolElt
{.}
    return (R1`M eq R2`M) and (R1`disc eq R2`disc);
end intrinsic; 

intrinsic IsCoercible(R::RngEtaQuot, x::.) -> BoolElt, .
{.}
    if Type(x) eq RngIntElt then
        return true, x*EtaQuotient(R, [0 : d in R`ds]);
    end if;
    if Type(x) eq EtaQuot then
        if Parent(x) eq R then return true, x; end if;
    end if;
    return false, _;
end intrinsic;

intrinsic '&+'(etas::SeqEnum[EtaQuot]) -> EtaQuot
{.}
    sum_etas := Universe(etas)!0;
    for eta in etas do
        sum_etas +:= eta;
    end for;
    return sum_etas;
end intrinsic;

intrinsic '*'(eta1::EtaQuot, eta2::EtaQuot) -> EtaQuot
{.}
    R := Parent(eta1);
    require R eq Parent(eta2) : "Eta quotients must belong to the same ring.";

    eta := New(EtaQuot);
    eta`parent := Type(BaseRing(Parent(eta2))) eq FldRat select Parent(eta2) else R;
    eta`coeffs := [c1*c2 : c1 in eta1`coeffs, c2 in eta2`coeffs];
    eta`eta_quots := [ [rs1[j] + rs2[j] : j in [1..#rs1]] : rs1 in eta1`eta_quots, rs2 in eta2`eta_quots];

    reduce(eta);

    if assigned eta1`qexp_oo and assigned eta2`qexp_oo then
        eta`qexp_oo := eta1`qexp_oo * eta2`qexp_oo;
        eta`prec_oo := Minimum(eta1`prec_oo + Valuation(eta2`qexp_oo), eta2`prec_oo + Valuation(eta1`qexp_oo));
    end if;

    if assigned eta1`qexp_0 and assigned eta2`qexp_0 then
        eta`qexp_0 := eta1`qexp_0 * eta2`qexp_0;
        eta`prec_0 := Minimum(eta1`prec_0 + Valuation(eta2`qexp_0), eta2`prec_0 + Valuation(eta2`qexp_0));
    end if;

    return eta;
end intrinsic;

// At the momnet simply doing square and multiply
intrinsic '^'(eta::EtaQuot, e::RngIntElt) -> EtaQuot
{.}
    R := Parent(eta);
    eta_e := R!1;
    base := eta;
    cur_exp := e;
    while cur_exp gt 0 do
        if IsOdd(cur_exp) then eta_e *:= base; end if;
        cur_exp div:= 2;
        base *:= base;
    end while;
    return eta_e;
end intrinsic;
