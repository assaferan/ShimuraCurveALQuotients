declare type RngEtaQuot[EtaQuot];

declare attributes RngEtaQuot : M, ds, nor_eta_ds, prec, disc, BaseRing;

declare attributes EtaQuot : parent, coeffs, qexp_oo, prec_oo, qexp_0, prec_0;

intrinsic EtaQuotientsRing(M::RngIntElt, disc::RngIntElt) -> RngEtaQuot
{The ring of integral linear combinations of eta quotients generated by eta(d*t) for d dividing M and a lattice L of discriminant disc.}
    R := New(RngEtaQuot);
    R`M := M;
    R`ds := Divisors(M);
    R`BaseRing := Integers();
    R`prec := -1;
    R`disc := disc;
    R`nor_eta_ds := [];
   
    return R;
end intrinsic;

intrinsic BaseRing(R::RngEtaQuot) -> RngEtaQuot
{.}
    return R`BaseRing;
end intrinsic;

intrinsic Precision(R::RngEtaQuot) -> RngIntElt
{.}
    return R`prec;
end intrinsic;

intrinsic EtaQuotient(exps::SeqEnum[RngIntElt], M::RngIntElt, disc::RngIntElt) -> EtaQuot
{Return the eta quotient \prod eta(d*t)^exps[i] where d is the i-th element of Divisors(M)}
    R := EtaQuotientsRing(M, disc);
    eta := New(EtaQuot);
    eta`parent := R;
    eta`coeffs := AssociativeArray();
    eta`coeffs[exps] := 1;

    // If this is a constant we create the precise q-expansions
    if &and[exp eq 0 : exp in exps] then
        Zq<q> := LaurentSeriesRing(Integers());
        eta`qexp_oo := Zq!1;
        eta`prec_oo := Infinity();
        eta`qexp_0 := Zq!1;
        eta`prec_0 := Infinity();
    end if;

    return eta;
end intrinsic;

intrinsic EtaQuotient(R::RngEtaQuot, exps::SeqEnum[RngIntElt]) -> EtaQuot
{Return the eta quotient \prod eta(d*t)^exps[i] where d is the i-th element of Divisors(M)}
    eta := New(EtaQuot);
    eta`parent := R;
    eta`coeffs := AssociativeArray();
    eta`coeffs[exps] := 1;
    
    // If this is a constant we create the precise q-expansions
    if &and[exp eq 0 : exp in exps] then
        Zq<q> := LaurentSeriesRing(Integers());
        eta`qexp_oo := Zq!1;
        eta`prec_oo := Infinity();
        eta`qexp_0 := Zq!1;
        eta`prec_0 := Infinity();
    end if;
    return eta;
end intrinsic;

intrinsic Parent(eta::EtaQuot) -> RngEtaQuot
{.}
    return eta`parent;
end intrinsic;

procedure update_precision_eta(~nor_eta_ds, Prec, ds)
    _<q> := LaurentSeriesRing(Integers());
    nor_eta := &*[1 - q^n : n in [1..Prec-1]] + O(q^(Prec));
    // eta_ds := [Evaluate(nor_eta, q^d)*q^(d/24) : d in Divisors(M)];
    nor_eta_ds := [Evaluate(nor_eta, q^d) + O(q^Prec) : d in ds];
    return;
end procedure;

procedure reduce(eta)
    zero_coeffs := [r : r in Exponents(eta) | eta`coeffs[r] eq 0];
    for r in zero_coeffs do
        Remove(~eta`coeffs, r);
    end for;
    return;
end procedure;

function valuation_at_oo_lb(eta)
    R := Parent(eta);
    reduce(eta);
    if IsEmpty(Keys(eta`coeffs)) then return Infinity(); end if;
    valuation_shifts := [&+[d*r[i] : i->d in R`ds] div 24 : r in Keys(eta`coeffs)];
    return Minimum(valuation_shifts);
end function;

intrinsic qExpansionAtoo(eta::EtaQuot, Prec::RngIntElt) -> RngSerLaurElt
{The q-expansion of eta at oo.}
    R := Parent(eta);
    
    if assigned eta`qexp_oo and Prec le eta`prec_oo then
         _<q> := Universe(R`nor_eta_ds);
        return eta`qexp_oo + O(q^Prec);
    end if;

    reduce(eta);

    if IsEmpty(Keys(eta`coeffs)) then 
        Zq<q> := LaurentSeriesRing(Integers());
        eta`qexp_oo := Zq!0;
        eta`prec_oo := Infinity();
        return eta`qexp_oo + O(q^Prec);
    end if;

    eta_quots := Exponents(eta);

    // We only store normalized eta quotients, these are the powers of q that we will need to eventually multiply by
    // to get the original eta quotients
    valuation_shifts := [&+[d*r[i] : i->d in R`ds] div 24 : r in eta_quots];
    prec_shift := Minimum(valuation_shifts);
    prec := Maximum(Prec - prec_shift, 1);
    // If we are not able to compute the q-expansion to the desired precision, we set prec to 1
    // so that we will not attempt to update the precision of the eta quotients

    if prec gt Precision(R) then 
        // curious - we are able to update something that does not exist ?
        update_precision_eta(~R`nor_eta_ds, prec, R`ds);
        R`prec := prec;
    end if;

    _<q> := Universe(R`nor_eta_ds);
    
    coeffs := [eta`coeffs[x] : x in eta_quots];

    prod_nor_etas := [&*[(R`nor_eta_ds[i] + O(q^prec))^r[i] : i->d in R`ds] : r in eta_quots];
    prod_etas := [prod_nor_etas[j] * q^valuation_shifts[j] : j->r in eta_quots];

    eta`qexp_oo := &+[c*prod_etas[j] : j->c in coeffs];
    eta`prec_oo := Prec;

    return eta`qexp_oo + O(q^Prec);
end intrinsic;

intrinsic SAction(eta::EtaQuot : Admissible := true) -> EtaQuot
{Returns (f | S)(q^M) as in [GY, Lemma 26].}
    R := Parent(eta);
    S_eta := New(EtaQuot);
    S_eta`parent := R;
    reduce(eta);
    S_eta`coeffs := AssociativeArray();
    
    for r in Exponents(eta) do
        sqr_fac := &*[d^r[i] : i->d in R`ds];
        if Admissible then sqr_fac *:= R`disc; end if;
        is_sqr, scale := IsSquare(sqr_fac);
        assert is_sqr;
        S_eta`coeffs[Reverse(r)] := eta`coeffs[r] / scale;
    end for;
    
    if Admissible then return R`M*S_eta; end if;
    return S_eta;
end intrinsic;

// This is Lemma 26 - q-expansion at 0 (multiplied by M if admissible)
intrinsic qExpansionAt0(eta::EtaQuot, Prec::RngIntElt : Admissible := true) -> RngSerLaurElt
{The q-expansion of eta at 0.}
    R := Parent(eta);
    if assigned eta`qexp_0 and Prec le eta`prec_0 then
         _<q> := Universe(R`nor_eta_ds);
        return eta`qexp_0 + O(q^Prec);
    end if;
    eta`qexp_0 := qExpansionAtoo(SAction(eta : Admissible := Admissible), Prec);
    eta`prec_0 := Prec;
    return eta`qexp_0;
end intrinsic;

intrinsic Print(eta::EtaQuot)
{.}
    val_lb := valuation_at_oo_lb(eta);
    default_prec := 12;
    printf "%o", qExpansionAtoo(eta, default_prec + val_lb);
end intrinsic;

intrinsic Print(R::RngEtaQuot)
{.}
    printf "Ring of eta quotients of level %o.", R`M;
end intrinsic;

intrinsic Coefficients(eta::EtaQuot) -> SeqEnum[RngIntElt]
{.}
    return [eta`coeffs[k] : k in Exponents(eta)];
end intrinsic;

intrinsic Exponents(eta::EtaQuot) -> SeqEnum[SeqEnum[RngIntElt]]
{.}
    return Sort([x : x in Keys(eta`coeffs)]);
end intrinsic;

// Arithmetic
intrinsic '+'(eta1::EtaQuot, eta2::EtaQuot) -> EtaQuot
{.}
    R := Parent(eta1);
    require R eq Parent(eta2) : "Eta quotients must belong to the same ring.";

    eta := New(EtaQuot);
    eta`parent := Type(BaseRing(Parent(eta2))) eq FldRat select Parent(eta2) else R;

    eta`coeffs := AssociativeArray();
    for r in Keys(eta1`coeffs) do
        eta`coeffs[r] := eta1`coeffs[r];
    end for;

    for r in Keys(eta2`coeffs) do
        if not IsDefined(eta`coeffs, r) then eta`coeffs[r] := 0; end if;
        eta`coeffs[r] +:= eta2`coeffs[r];
    end for;

    reduce(eta);

    if assigned eta1`qexp_oo and assigned eta2`qexp_oo then
        eta`qexp_oo := eta1`qexp_oo + eta2`qexp_oo;
        eta`prec_oo := Minimum(eta1`prec_oo, eta2`prec_oo);
    end if;

    if assigned eta1`qexp_0 and assigned eta2`qexp_0 then
        eta`qexp_0 := eta1`qexp_0 + eta2`qexp_0;
        eta`prec_0 := Minimum(eta1`prec_0, eta2`prec_0);
    end if;

    return eta;
end intrinsic;

intrinsic '*'(a::RngIntElt, eta::EtaQuot) -> EtaQuot
{.}
    eta_a := New(EtaQuot);
    eta_a`parent := Parent(eta);
    eta_a`coeffs := AssociativeArray();

    for r in Keys(eta`coeffs) do
        eta_a`coeffs[r] := a * eta`coeffs[r];
    end for;

    reduce(eta_a);

    if assigned eta`qexp_oo then
        eta_a`qexp_oo := a*eta`qexp_oo;
        eta_a`prec_oo := eta`prec_oo;
    end if;

    if assigned eta`qexp_0 then
        eta_a`qexp_0 := a*eta`qexp_0;
        eta_a`prec_0 := eta`prec_0;
    end if;

    return eta_a;
end intrinsic;

intrinsic '*'(a::FldRatElt, eta::EtaQuot) -> EtaQuot
{.}
    eta_a := New(EtaQuot);
    eta_a`parent := Parent(eta);
    eta_a`parent`BaseRing := Rationals();
    eta_a`coeffs := AssociativeArray();

    for r in Keys(eta`coeffs) do
        eta_a`coeffs[r] := a * eta`coeffs[r];
    end for;
    
    reduce(eta_a);

    if assigned eta`qexp_oo then
        eta_a`qexp_oo := a*eta`qexp_oo;
        eta_a`prec_oo := eta`prec_oo;
    end if;

    if assigned eta`qexp_0 then
        eta_a`qexp_0 := a*eta`qexp_0;
        eta_a`prec_0 := eta`prec_0;
    end if;

    return eta_a;
end intrinsic;

intrinsic '-'(eta1::EtaQuot, eta2::EtaQuot) -> EtaQuot
{.} 
    return eta1 + (-1)*eta2;
end intrinsic;

intrinsic 'eq'(R1::RngEtaQuot, R2::RngEtaQuot) -> BoolElt
{.}
    return (R1`M eq R2`M) and (R1`disc eq R2`disc);
end intrinsic; 

intrinsic IsCoercible(R::RngEtaQuot, x::.) -> BoolElt, .
{.}
    if Type(x) eq RngIntElt then
        return true, x*EtaQuotient(R, [0 : d in R`ds]);
    end if;
    if Type(x) eq EtaQuot then
        if Parent(x) eq R then return true, x; end if;
    end if;
    return false, _;
end intrinsic;

intrinsic '&+'(etas::SeqEnum[EtaQuot]) -> EtaQuot
{.}
    sum_etas := Universe(etas)!0;
    for eta in etas do
        sum_etas +:= eta;
    end for;
    return sum_etas;
end intrinsic;

intrinsic '*'(eta1::EtaQuot, eta2::EtaQuot) -> EtaQuot
{.}
    R := Parent(eta1);
    require R eq Parent(eta2) : "Eta quotients must belong to the same ring.";

    eta := New(EtaQuot);
    eta`parent := Type(BaseRing(Parent(eta2))) eq FldRat select Parent(eta2) else R;

    eta`coeffs := AssociativeArray();

    for rs1 in Keys(eta1`coeffs) do
        for rs2 in Keys(eta2`coeffs) do
            rs := [rs1[j] + rs2[j] : j in [1..#rs1]];
            if not IsDefined(eta`coeffs, rs) then eta`coeffs[rs] := 0; end if;
            eta`coeffs[rs] +:= eta1`coeffs[rs1]*eta2`coeffs[rs2];
        end for;
    end for;

    reduce(eta);

    if assigned eta1`qexp_oo and assigned eta2`qexp_oo then
        eta`qexp_oo := eta1`qexp_oo * eta2`qexp_oo;
        eta`prec_oo := Minimum(eta1`prec_oo + Valuation(eta2`qexp_oo), eta2`prec_oo + Valuation(eta1`qexp_oo));
    end if;

    if assigned eta1`qexp_0 and assigned eta2`qexp_0 then
        eta`qexp_0 := eta1`qexp_0 * eta2`qexp_0;
        eta`prec_0 := Minimum(eta1`prec_0 + Valuation(eta2`qexp_0), eta2`prec_0 + Valuation(eta2`qexp_0));
    end if;

    return eta;
end intrinsic;

// At the momnet simply doing square and multiply
intrinsic '^'(eta::EtaQuot, e::RngIntElt) -> EtaQuot
{.}
    R := Parent(eta);
    eta_e := R!1;
    base := eta;
    cur_exp := e;
    while cur_exp gt 0 do
        if IsOdd(cur_exp) then eta_e *:= base; end if;
        cur_exp div:= 2;
        base *:= base;
    end while;
    return eta_e;
end intrinsic;
