declare type RngEtaQuot[EtaQuot];

declare attributes RngEtaQuot : M, ds, nor_eta_ds, prec, disc, BaseRing;

declare attributes EtaQuot : parent, coeffs, eta_quots;

intrinsic EtaQuotientsRing(M::RngIntElt, disc::RngIntElt) -> RngEtaQuot
{The ring of integral linear combinations of eta quotients generated by eta(d*t) for d dividing M and a lattice L of discriminant disc.}
    R := New(RngEtaQuot);
    R`M := M;
    R`ds := Divisors(M);
    R`BaseRing := Integers();
    R`prec := -1;
    R`disc := disc;
    R`nor_eta_ds := [];
    return R;
end intrinsic;

intrinsic BaseRing(R::RngEtaQuot) -> RngEtaQuot
{.}
    return R`BaseRing;
end intrinsic;

intrinsic Precision(R::RngEtaQuot) -> RngIntElt
{.}
    return R`prec;
end intrinsic;

intrinsic EtaQuotient(exps::SeqEnum[RngIntElt], M::RngIntElt, disc::RngIntElt) -> EtaQuot
{Return the eta quotient \prod eta(d*t)^exps[i] where d is the i-th element of Divisors(M)}
    R := EtaQuotientsRing(M, disc);
    eta := New(EtaQuot);
    eta`parent := R;
    eta`coeffs := [1];
    eta`eta_quots := [exps];
    return eta;
end intrinsic;

intrinsic EtaQuotient(R::RngEtaQuot, exps::SeqEnum[RngIntElt]) -> EtaQuot
{Return the eta quotient \prod eta(d*t)^exps[i] where d is the i-th element of Divisors(M)}
    eta := New(EtaQuot);
    eta`parent := R;
    eta`coeffs := [1];
    eta`eta_quots := [exps];
    return eta;
end intrinsic;


intrinsic Parent(eta::EtaQuot) -> RngEtaQuot
{.}
    return eta`parent;
end intrinsic;

procedure update_precision_eta(~nor_eta_ds, Prec, ds)
    _<q> := LaurentSeriesRing(Integers());
    nor_eta := &*[1 - q^n : n in [1..Prec-1]] + O(q^(Prec));
    // eta_ds := [Evaluate(nor_eta, q^d)*q^(d/24) : d in Divisors(M)];
    nor_eta_ds := [Evaluate(nor_eta, q^d) + O(q^Prec) : d in ds];
    return;
end procedure;

intrinsic qExpansionAtoo(eta::EtaQuot, Prec::RngIntElt) -> RngSerLaurElt
{The q-expansion of eta at oo.}
    R := Parent(eta);
    if Prec gt Precision(R) then 
        // curious - we are able to update something that does not exist ?
        update_precision_eta(~R`nor_eta_ds, Prec, R`ds);
        R`prec := Prec;
    end if;
    _<q> := Universe(R`nor_eta_ds);
    prod_nor_etas := [&*[R`nor_eta_ds[i]^r[i] : i->d in R`ds] : r in eta`eta_quots];
    prod_etas := [prod_nor_etas[j] * q^(&+[d*r[i] : i->d in R`ds] div 24) : j->r in eta`eta_quots];

    return &+[c*prod_etas[j] : j->c in eta`coeffs] + O(q^Prec);
end intrinsic;

// This is Lemma 26 - q-expansion at 0 (multiplied by M if admissible)
intrinsic qExpansionAt0(eta::EtaQuot, Prec::RngIntElt : Admissible := true) -> RngSerLaurElt
{The q-expansion of eta at 0.}
    R := Parent(eta);
    if Prec gt Precision(R) then 
        update_precision_eta(~R`nor_eta_ds, Prec, R`ds);
        R`prec := Prec;
    end if;
    _<q> := Universe(R`nor_eta_ds);
    non_zero_coeffs := [i : i->c in eta`coeffs | c ne 0];
    eta`coeffs := [eta`coeffs[i] : i in non_zero_coeffs];
    eta`eta_quots := [eta`eta_quots[i] : i in non_zero_coeffs];
    sqr_factors := [&*[d^r[i] : i->d in R`ds] : r in eta`eta_quots];
    if Admissible then sqr_factors := [sqr_fac*R`disc : sqr_fac in sqr_factors]; end if;
    scales := [];
    for sqr_factor in sqr_factors do
        is_sqr, scale := IsSquare(sqr_factor);
        assert is_sqr;
        Append(~scales, scale);
    end for;
    prod_nor_etas := [&*[R`nor_eta_ds[#R`ds+1-i]^r[i] : i->d in R`ds] : r in eta`eta_quots];
    prod_etas := [prod_nor_etas[j] * q^(&+[(R`M div d)*r[i] : i->d in R`ds] div 24) : j->r in eta`eta_quots];
    lin_comb := &+[c*prod_etas[j]/scales[j] : j->c in eta`coeffs];
    if Admissible then return lin_comb*R`M + O(q^Prec); end if;
    return lin_comb + O(q^Prec);
end intrinsic;

intrinsic Print(eta::EtaQuot)
{.}
    default_prec := 12;
    printf "%o", qExpansionAtoo(eta, default_prec);
end intrinsic;

intrinsic Print(R::RngEtaQuot)
{.}
    printf "Ring of eta quotients of level %o.", R`M;
end intrinsic;

intrinsic Coefficients(eta::EtaQuot) -> SeqEnum[RngIntElt]
{.}
    return eta`coeffs;
end intrinsic;

intrinsic Exponents(eta::EtaQuot) -> SeqEnum[SeqEnum[RngIntElt]]
{.}
    return eta`eta_quots;
end intrinsic;

// Arithmetic
intrinsic '+'(eta1::EtaQuot, eta2::EtaQuot) -> EtaQuot
{.}
    R := Parent(eta1);
    require R eq Parent(eta2) : "Eta quotients must belong to the same ring.";

    eta := New(EtaQuot);
    eta`parent := R;
    eta`coeffs := eta1`coeffs cat eta2`coeffs;
    eta`eta_quots := eta1`eta_quots cat eta2`eta_quots;

    return eta;
end intrinsic;

intrinsic '*'(a::RngIntElt, eta::EtaQuot) -> EtaQuot
{.}
    eta_a := New(EtaQuot);
    eta_a`parent := Parent(eta);
    eta_a`coeffs := [a*c : c in eta`coeffs];
    eta_a`eta_quots := eta`eta_quots;

    return eta_a;
end intrinsic;

intrinsic '*'(a::FldRatElt, eta::EtaQuot) -> EtaQuot
{.}
    eta_a := New(EtaQuot);
    eta_a`parent := Parent(eta);
    eta_a`parent`BaseRing := Rationals();
    eta_a`coeffs := [a*c : c in eta`coeffs];
    eta_a`eta_quots := eta`eta_quots;

    return eta_a;
end intrinsic;

intrinsic '-'(eta1::EtaQuot, eta2::EtaQuot) -> EtaQuot
{.} 
    return eta1 + (-1)*eta2;
end intrinsic;

intrinsic 'eq'(R1::RngEtaQuot, R2::RngEtaQuot) -> BoolElt
{.}
    return (R1`M eq R2`M) and (R1`disc eq R2`disc);
end intrinsic; 

intrinsic IsCoercible(R::RngEtaQuot, x::.) -> BoolElt, .
{.}
    if Type(x) eq RngIntElt then
        return true, x*EtaQuotient(R, [0 : d in R`ds]);
    end if;
    if Type(x) eq EtaQuot then
        if Parent(x) eq R then return true, x; end if;
    end if;
    return false, _;
end intrinsic;

intrinsic '&+'(etas::SeqEnum[EtaQuot]) -> EtaQuot
{.}
    sum_etas := Universe(etas)!0;
    for eta in etas do
        sum_etas +:= eta;
    end for;
    return sum_etas;
end intrinsic;