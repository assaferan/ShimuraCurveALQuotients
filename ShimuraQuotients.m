// File for determining the hyperelliptic quotients of Shimura curves
// of the form X_0(D,N)

// Committed to Geometrically Hyperelliptic curves


declare verbose ShimuraQuotients, 3;

import "TraceFormula.m" : TraceFormulaGamma0HeckeAL,
       TraceFormulaGamma0HeckeALNew,
       get_ds, n_prime, d_prime, dd_prime, Q_prime;
import "Caching.m" : CacheClearOrders, SetCache, GetCache, cached_orders;

// D - Discriminant of Quaternion algebra
// N - Level of Eichler order
// W - set of d | DN such that the group generated by w_d,
// the corresponding Atkin-Lehner involutions, is the group we quotient by
// g - Genus of the quotient
// CurveID - a unique identifier
// CoveredBy - CurveIDs of the curves directly covering it
// Covers - CurveIDs of the curves it is directly covering
// IsP1 - f isomorphic to P1 (geom.), g = 0
// IsEC - if elliptic curve (geom.), g = 1
// IsHyp - if hyperelliptic (neither elliptic, nor p1)
// IsSubhyp - if subhyperelliptic (i.e. any of the above)

intrinsic IsEqualCurve(crv1::ShimuraQuot, crv2::ShimuraQuot) ->BoolElt
    {returns true if they are equal}
    if (crv1`D ne crv2`D) then
    return false;
    end if;
    if (crv1`N ne crv2`N) then
    return false;
    end if;
    if (crv1`W ne crv2`W) then
    return false;
    end if;
    if (crv1`g ne crv2`g) then
    return false;
    end if;
    if (assigned crv1`IsP1) then
    if not assigned crv2`IsP1 then
        return false;
    end if;
    if (crv1`IsP1 ne crv2`IsP1) then
        return false;
    end if;
    end if;
    if (assigned crv1`IsEC) then
    if not assigned crv2`IsEC then
        return false;
    end if;
    if (crv1`IsEC ne crv2`IsEC) then
        return false;
    end if;
    end if;
    if (assigned crv1`IsHyp) then
    if not assigned crv2`IsHyp then
        return false;
    end if;
    if (crv1`IsHyp ne crv2`IsHyp) then
        return false;
    end if;
    end if;
    if (assigned crv1`IsSubhyp) then
    if not assigned crv2`IsSubhyp then
        return false;
    end if;
    if (crv1`IsSubhyp ne crv2`IsSubhyp) then
        return false;
    end if;
    end if;
    return true;
end intrinsic;

// Lower and upper bounds for number of points in reduction mod p,
// scaled by 12/p-1, see [HH]

intrinsic Omega(n::RngIntElt) -> RngIntElt
    {Omega(n)}
    return #PrimeDivisors(n);
end intrinsic;

intrinsic FirstPrimes(n::RngIntElt) -> SeqEnum
    {Return firt primes up to bound}
    ps := PrimesUpTo(1+Ceiling(n*(Log(n+1)+Log(Log(n+1)))));
    assert #ps ge n;
    return ps[1..n];
end intrinsic;

intrinsic LowerBoundD(D::RngIntElt) -> FldRatElt
    {}
    return EulerPhi(D)/ 2^Omega(D);
end intrinsic;

intrinsic LowerBoundN(N::RngIntElt) -> FldRatElt
    {}
    ps := PrimeDivisors(N);
    if N eq 1 then
        c_N := 1;
       else
        c_N := N * &*[ 1 + 1/p : p in ps];
    end if;
    return c_N / 2^Omega(N);
end intrinsic;

intrinsic LowerBound(D::RngIntElt, N::RngIntElt, p::RngIntElt: lb:=false) -> FldRatElt
    {Lower bound on the number of Fp rational points on the star quotient}
    if lb cmpeq false then
        lb := LowerBoundD(D)*LowerBoundN(N);
    end if;
    if D eq 1 then
        h := Maximum([h : h in [ 1, 2, 3, 4, 6, 8, 12, 24 ] | N mod h^2 eq 0]);
        h2 := GCD(h,8); h3 := GCD(h,3);
        cond2 := IsEven(h2) and (N mod h2^2 eq 0) and
             (GCD(h2^2, N div h2^2) eq 1);
        s2 := cond2 select 3/4 else 1;
        cond3 := (h3 eq 3) and Valuation(N, 3) eq 2;
        s3 := cond3 select 2/3 else 1;
        s := s2*s3;
        lb +:= 12*h*s/(p-1);
    end if;
    return lb;
end intrinsic;

intrinsic UpperBound(p ::RngIntElt : Geometric := true) -> FldRatElt
    {Upper bound on the number of Fp-rational points on the star quotient}
    // We use the fact that the geometric gonality is 2
    // so gonality over Q (hence also over F_p) is at most 4
    gonality := 2;
    /* Not needed in the hyperelliptic case, because of [Poonen, Thm 2.5(i)]
    if Geometric then
    gonality := gonality^2;
    end if;
    */
    return 12*gonality*(1+p^2)/(p-1);
end intrinsic;

intrinsic MinimalNumberOfALinQuotient(D::RngIntElt, N::RngIntElt) -> RngIntElt
    {Min number of ALs in quotient to be subhyperelliptic according to point counts over Fp}
    ps := PrimeDivisors(N);
    c_D := EulerPhi(D);
    c_N := N * &*[Rationals() | 1 + 1/p : p in ps];
    p := 2;
    while (N mod p eq 0) do
    p := NextPrime(p);
    end while;
    return Maximum(0,Ceiling(Log(2, (c_D * c_N) / UpperBound(p))));
end intrinsic;

intrinsic VerifyBound(r::RngIntElt)
    {Verifies bound}
    ps := FirstPrimes(r+1);
    assert LowerBoundN(&*ps[1..r]) gt UpperBound(ps[r+1] :
                         Geometric := false);
    assert LowerBoundD(&*ps[1..r]) gt UpperBound(ps[r+1]);
end intrinsic;

intrinsic GetLargestPrimeIndex() -> RngIntElt
    {}
    p := 1;
    prod := 1;
    LB := 1;
    UB := 1;
    r := -1;
    while (LB le UB) do
    prod *:= p;
    p := NextPrime(p);
    LB := LowerBoundD(prod);
    UB := UpperBound(p);
    r +:= 1;
    end while;
    VerifyBound(r);
    return r;
end intrinsic;

intrinsic FindMaximalN(r::RngIntElt) -> RngIntElt
    {}
    ps := FirstPrimes(r);
    return Floor(UpperBound(ps[r])*2^(r-1));
end intrinsic;

// Using https://math.stackexchange.com/questions/301837/is-the-euler-phi-function-bounded-below EEDDIITT -> TODO: Find a reference
intrinsic FindMaximalD(r::RngIntElt) -> RngIntElt
    {}
    ps := FirstPrimes(r);
    ub := Ceiling(UpperBound(ps[r]));
    C := 2^(r-1)*ub;
    p := 2;
    prev := Infinity();
    bound := Infinity();
    A := p;
    RR := RealField();
    r := 1;
    while (bound le prev) do
    p := NextPrime(p);
    delta := RR!(1 - Log(p-1) / Log(p));
    A *:= p;
    r +:= 1;
    prev := bound;
    bound := Ceiling(A*(C/EulerPhi(A))^(1/(1-delta)));
    // print "bound = ", bound;
    end while;
    return bound; //, r, A;
end intrinsic;

intrinsic FindPairs(r :: RngIntElt: Coprime := true) -> SeqEnum
    {Find all curves X_0*(D,N) which might be subhyperelliptic, D and N coprime}
    pairs := [];
    // N0 := FindMaximalN(r);
    ps := FirstPrimes(r);
    ub := Ceiling(UpperBound(ps[r]));
    C := 2^(r-1)*ub;
    D0 := FindMaximalD(r);
    // Ds := [D : D in [1..D0] | IsSquarefree(D) and IsEven(Omega(D))];
    Ds := [D : D in [1..D0] | MoebiusMu(D) eq 1];

    // stores LowerBoundN on [1..C]
    lNs := [LowerBoundN(N) : N in [1..C]];
    for D in Ds do
        lD := LowerBoundD(D);
        // print "D = ", D;
        // Nmax := Floor(N0 / EulerPhi(D));
        Nmax := Ceiling(C / EulerPhi(D));
        Ns := [1..Nmax];
        if Coprime then
            Ns := [N : N in Ns | GCD(D,N) eq 1];
        end if;

        for N in Ns do
            /*
            if (N mod 1000 eq 0) then
            print "N =", N;
            end if;
           */
            p := 2;
            while (N mod p eq 0) do
            p := NextPrime(p);
            end while;
            if D ne 1 then
                if lD*lNs[N] le UpperBound(p) then
                    W := {d : d in Divisors(D*N) | GCD(d, (D*N) div d) eq 1};
                    vprint ShimuraQuotients, 3: W;
                    //Append(~pairs, rec<CurveQuot | D := D, N := N, W := W >);
                    S := CreateShimuraQuot(D, N, W);
                    Append(~pairs, S);
                end if;
            else
                if (LowerBound(D, N, p) le UpperBound(p)) then
                    W := {d : d in Divisors(D*N) | GCD(d, (D*N) div d) eq 1};
                    vprint ShimuraQuotients, 3: W;
                    S := CreateShimuraQuot(D, N, W);
                    //Append(~pairs, rec<CurveQuot | D := D, N := N, W := W >);
                    Append(~pairs, S);
                end if;
            end if;
        end for;
    end for;
    for i->pair in pairs do
	pairs[i]`CurveID := i;
    end for;
    return pairs;
end intrinsic;

// 2 corresponds to cusps, 3, 4
intrinsic NumberOfEllipticPoints(D::RngIntElt, N::RngIntElt, order::RngIntElt)-> RngIntElt
    {}
    if order eq 2 then
        if D eq 1 then
            return &+[EulerPhi(GCD(d, N div d)) : d in Divisors(N)];
        else
            return 0;
        end if;
    end if;
    if order eq 4 then
        Q := 4;
    end if;
    if order eq 3 then
        Q := 9;
    end if;
    if (N mod Q eq 0) then
        return 0;
    end if;
    primesD := PrimeDivisors(D);
    primesN := PrimeDivisors(N);
    e_D := &*[Integers() | 1 - KroneckerSymbol(-order, p) : p in primesD];
    e_N := &*[Integers() | 1 + KroneckerSymbol(-order, p) : p in primesN];
    return e_D * e_N;
end intrinsic;

intrinsic GenusShimuraCurve(D::RngIntElt, N::RngIntElt) -> RngIntElt
    {}
    phiD := EulerPhi(D);
    primes := PrimeDivisors(N);
    P1N := Floor(N * &*[Rationals() | 1 + 1/p : p in primes]);
    g := 1 + phiD * P1N / 12;
    e := AssociativeArray();
    for h in [2,3,4] do
	e[h] := NumberOfEllipticPoints(D, N, h);
	g -:= e[h] / h;
    end for;
    assert IsIntegral(g);
    return Floor(g);
end intrinsic;

intrinsic PsiOgg(p::RngIntElt, n::RngIntElt) ->RngIntElt
    {}
    if (n eq 1) then
    return 1;
    end if;
    is_prime_power, q, k := IsPrimePower(n);
    if (is_prime_power) then
    return ((q eq p) select Floor(p^k *(1 + 1/p)) else 1);
    end if;
    fac := Factorization(n);
    return &*[Integers() | PsiOgg(p, pe[1]^pe[2]) : pe in fac];
end intrinsic;

function LegendreSymbol(R, p)
    f := Conductor(R);
    if (f mod p eq 0) then
        return 1;
    end if;
    ZF := MaximalOrder(R);
    return KroneckerSymbol(Discriminant(ZF),p);
end function;

// Here R is the quadratic order and
// O is a fixed quaternion Eichler order of level F in
// the quaternion algebra B of discriminant D.
// based on Theorem 2 in [Ogg]
function NuOgg(p, R, D, F)
    if (D mod p eq 0) then
        return 1 - LegendreSymbol(R, p);
    end if;
    if Valuation(F, p) eq 1 then
        return 1 + LegendreSymbol(R, p);
    end if;
    assert Valuation(F, p) ge 2;
    f := Conductor(R);
    ZF := MaximalOrder(R);
    chip := KroneckerSymbol(Discriminant(ZF),p);
    k := Valuation(f, p);
    K := Valuation(F, p);
    if (K ge 2*(1 + k)) then
    if (chip eq 1) then
        return 2*PsiOgg(p, f);
    end if;
    return 0;
    end if;
    if (K eq 1 + 2*k) then
    if (chip eq 1) then
        return 2*PsiOgg(p, f);
    end if;
    if (chip eq 0) then
        return p^k;
    end if;
    assert chip eq -1;
    return 0;
    end if;
    if (K eq 2*k) then
    return p^(k-1)*(p+1+chip);
    end if;
    if (K le 2*k - 1) then
    if IsEven(K) then
        return p^(k div 2) + p^(k div 2 - 1);
    else
        return 2*p^(k div 2);
    end if;
    end if;
    // Should not reach here
    assert false;
end function;


function SquarePart(m)
    fac := Factorization(m);
    prod := 1;
    for f in fac do
        if f[2] ge 2 then
            if IsEven(f[2]) then
                prod *:=  Integers()!(f[1]^(Integers()!f[2]/2));
            else
                prod *:=  Integers()!(f[1]^(Integers()!(f[2]-1)/2));
            end if;
        end if;
    end for;
    return prod;
end function;

intrinsic ConstructOrders(m  :: RngIntElt) ->SeqEnum
    {}
    b, v := GetCache(m, cached_orders);
    if b then
        return v;

    else
        if (m eq 2) then
            orders := [MaximalOrder(QuadraticField(-1)),
                   MaximalOrder(QuadraticField(-2))];
        elif (m mod 4 eq 3) then
            F<a> := QuadraticField(-m);
            // _, sqrt_minus_m := IsSquare(F!(-m));
            sqm := SquarePart(m);
            sqrt_minus_m:= sqm*a;
            O := MaximalOrder(F);
            alpha := (1 + sqrt_minus_m)/2;
            orders := [sub<O | 1, alpha>, sub<O | 1, 2*alpha>];
            // orders := [EquationOrder(x^2+x+((m+1) div 4)), EquationOrder(x^2+m)];
        else
            F<a> := QuadraticField(-m);
            sqm := SquarePart(m);
            sqrt_minus_m:= sqm*a;
            // _, sqrt_minus_m := IsSquare(F!(-m));
            O := MaximalOrder(F);
            orders := [sub<O | 1, sqrt_minus_m>];
            // orders := [EquationOrder(x^2+m)];
        end if;
        class_nums :=[];
        for R in orders do
            //compute info about orders and store it
            //let's start with just storing the class numbers
            h := PicardNumber(R);
            // h := #PicardGroup(R);
            Append(~class_nums, h);
        end for;
        v := [* orders, class_nums *];
        SetCache(m,v, cached_orders);
        return v;
    end if;

end intrinsic;

// Quotient by w_m, m divides DN, following [Ogg]

intrinsic NumFixedPoints(D ::RngIntElt, N ::RngIntElt, m::RngIntElt)-> RngIntElt
{The number of the fixed points of w_m on X_0(D,N)}
    e := 0;
    if (m eq 1) then return Infinity(); end if;
    pair := ConstructOrders(m);
    orders := pair[1];
    class_nums := pair[2];
    for i->R in orders do
        // h := PicardNumber(R);
        h := class_nums[i];
        // Using formula (4) in [Ogg]
        prod := &*[Integers() |
                    NuOgg(p, R, D, N) : p in PrimeDivisors(D*N) | m mod p ne 0];
        e +:= h*prod;
    end for;
    if (D eq 1) and (m eq 4) then
        M := N div 4;
        num_fixed_cusps := &+[Integers() | EulerPhi(GCD(d, M div d)) : d in Divisors(M)];
        e +:= num_fixed_cusps;
    end if;
    return e;
end intrinsic;

intrinsic GenusShimuraCurveQuotientSingleAL(D::RngIntElt, N::RngIntElt, m::RngIntElt)-> RingIntElt
    {Genus of X0(D,N)/< w_m>}
    e := NumFixedPoints(D, N, m);
    g_big := GenusShimuraCurve(D, N);
    g := (g_big+1)/2 - e/4;
    assert IsIntegral(g);
    return Floor(g);
end intrinsic;

intrinsic GenusShimuraCurveQuotient(D::RngIntElt, N::RngIntElt, als ::SetEnum) -> RingIntElt
    {Genus of X0(D,N)/<als>}
    total_e := 0;
    for al in als do
    assert GCD(al, (D*N) div al) eq 1;
    if (al ne 1) then
        total_e +:= NumFixedPoints(D, N, al );
    end if;
    end for;
    if #als eq 1 then
        s := 0;
    else
        is_prime_power, two, s := IsPrimePower(#als);
        assert is_prime_power and (two eq 2);
    end if;
    g_big := GenusShimuraCurve(D, N);
    g := 1 + (g_big - 1)/2^s - total_e/2^(s+1);
    assert IsIntegral(g);
    return Floor(g);
end intrinsic;

function exp_to_Q(e, N, ps)
    ZZ := Integers();
    e := Eltseq(e);
    P := Parent(e[1]);
    return &*[ZZ | ps[i]^Valuation(N,ps[i]) : i in [1..#ps] | e[i] eq P!1];
end function;

intrinsic al_mul(w::RngIntElt, m::RngIntElt, ND::RngIntElt) -> RngIntElt
    {multiply Atkin--Lehners w and m in X0(N,D)}
    ps := PrimeDivisors(ND);
    // ps := PrimeDivisors(w*m);
    wvals := Vector(Integers(), [Valuation(w, p) : p in ps]);
    mvals := Vector(Integers(), [Valuation(m, p) : p in ps]);
    // wmvals := mvals + wvals;
    wmvals := Vector(Integers(), [0 : p in ps]);
    for i in [1..#ps] do
        if wvals[i] eq 0 then
            wmvals[i] := mvals[i];
        elif mvals[i] eq 0 then
            wmvals[i] := wvals[i];
        else
            wmvals[i] := 0;
        end if;
    end for;
    wm := &*[ps[i]^(wmvals[i]) : i in [1..#ps]];
    return wm;
end intrinsic;

intrinsic ReduchedEchelonMatrixIterator(k::RngIntElt, n::RngIntElt : K := FiniteField(2)) -> SeqEnum
    {// copied from sage code
    /*An iterator over `(k,n)` reduced echelon matrices over the finite field `K`.

    INPUT:

    - ``K`` -- a finite field

    - ``k`` -- number of rows (or the size of the subspace)

    - ``n`` -- number of columns (or the dimension of the ambient space)*/}
    if n lt k then
        error "echelon matrix with fewer rows than columns i.e. not full rank are not implemented";
    end if;
    matrices := [];

    one := K!1;
    Klist := [x : x in K];
    //select pivot columns
    for pivots in Subsets({1..n},k) do
        sqpivots := SetToSequence(pivots);
        m0 := KMatrixSpace(K,k,n)!ZeroMatrix(K,k,n);
        free_positions := [];
        for i in [1..k] do
            m0[i,sqpivots[i]] := one;
            for j in [sqpivots[i]+1..n] do
                if j notin sqpivots then
                    Append(~free_positions,<i,j>);
                end if;
            end for;
        end for;
    //fill in the rest of the entries not determined by pivot columns/ RREF
        num_free_pos := #free_positions;
        for v in CartesianPower(Klist, num_free_pos) do
            for i in [1..num_free_pos] do
                    m0[free_positions[i][1], free_positions[i][2]] := v[i];
            end for;
            Append(~matrices, m0);
        end for;
     end for;

    return matrices;
end intrinsic;



// Returns a sequence of tuples,
// containing the divisors in the group, the indices of maximal subgroups
// and the indices of minimal overgroups


function MaxSubgroups(m, sl);
    r := #Rows(m);
    if r eq 0 then
        return {Integers()|};
    else
        all_mats :=  &cat[[* x : x in r *] : r in sl];
        subgps := {};
        for n in sl[r] do //rank r-1 things
            if RowSpace(n) subset RowSpace(m) then
                i := Index(all_mats, n);
                Include(~subgps, i);
            end if;
        end for;
        return subgps;
    end if;

end function;

function MinOvergps(m, sl);
    r := #Rows(m);
    all_mats :=  &cat[[* x : x in r *] : r in sl];
    if r eq #sl - 1 then
        return {Integers()|};
    else
        subgps := {};
        for n in sl[r+2] do
            if RowSpace(m) subset RowSpace(n) then
                i := Index(all_mats, n);
                Include(~subgps, i);
            end if;
        end for;
        return subgps;
    end if;
end function;

intrinsic AllALsFromGens(Ws::SetEnum, ND::RngIntElt) ->SetEnum
    {Get all ALs from a generating set}
    allws := {Integers()|};
    S := Subsets(Ws);
    for s in S do
        if #s eq 0 then
            Include(~allws, 1);
        else
            prod := 1;
            for w in s do
                prod := al_mul(w,prod, ND);
            end for;
            Include(~allws, prod);
        end if;
    end for;
    return allws;
end intrinsic;

intrinsic ALSubgroups(N::RngIntElt) -> SetEnum
    {All Atkin Lehner subgroups}
    ZZ := Integers();
    Qs_in_grp := AssociativeArray();
    ps := PrimeDivisors(N);
    Qs := [];
    subgp_lattice := [* *];
    for r in [0..#ps] do
        ms := ReduchedEchelonMatrixIterator(r,#ps);
        Append(~subgp_lattice, ms);
    end for;

    for rkgp in subgp_lattice do
        for m in rkgp do
            if #Rows(m) eq 0 then
                grp := {Integers()|};
            else
                grp := {Integers()|exp_to_Q(e,N,ps) : e in Rows(m)};
            end if;
            // print grp;
            // Include(~Qs, grp);
            grp := AllALsFromGens(grp, N);
            // print "generates", grp;
            Append(~Qs, <grp, MaxSubgroups(m, subgp_lattice), MinOvergps(m,subgp_lattice)>);
        end for;
    end for;

    return Qs;
end intrinsic;


intrinsic UpdateGenera(~curves::SeqEnum)
    {}
    for i->c in curves do
	curves[i]`g := GenusShimuraCurveQuotient(c`D, c`N, c`W);
    end for;
end intrinsic;

intrinsic GetQuotientsAndGenera(curves) -> SeqEnum
    {}
    quots := [];
    for i->c in curves do
        min_num := MinimalNumberOfALinQuotient(c`D, c`N);
        al_subs := ALSubgroups(c`D*c`N);
        allowed_idxs := [j : j in [1..#al_subs] | #al_subs[j][1] ge 2^min_num];
        update_idxs := func < S | {Index(allowed_idxs, idx)
                           : idx in S | idx in allowed_idxs}>;
        allowed_subs := [<al_subs[j][1],
                        update_idxs(al_subs[j][2]),
                        update_idxs(al_subs[j][3])>
                        : j in allowed_idxs];
        cur_sz := #quots;
        for j->S in allowed_subs do
            als := S[1];
            g := GenusShimuraCurveQuotient(c`D, c`N, als);
            quot := CreateShimuraQuot(c`D, c`N, als);
            quot`g := g;
            quot`CurveID := cur_sz + j;
            quot`CoveredBy := {cur_sz + idx : idx in S[2]};
            quot`Covers := {cur_sz + idx : idx in S[3]};
            Append(~quots, quot);
        end for;
        if (i mod 100 eq 0) then
            print "i = ", i, "/", #curves;
        end if;
    end for;
    return quots;
end intrinsic;

// Can work faster if we first compute all the traces (half the work)
/*
function sum_n_powers(mfs, p, n, BV)
    assert n ge 1;
    assert Level(mfs) mod p ne 0;
    T_p_n := HeckeOperator(mfs, p^n);
    T_p_n := ChangeRing(T_p_n, Rationals());
    T_p_n := Solution(BV, BV*T_p_n);
    if n eq 1 then
    return Trace(T_p_n);
    end if;
    T_p_n_2 := HeckeOperator(mfs, p^(n-2));
    T_p_n_2 := ChangeRing(T_p_n_2, Rationals());
    T_p_n_2 := Solution(BV, BV*T_p_n_2);
    return Trace(T_p_n - p*T_p_n_2);
end function;
*/

function TraceDNew(D,N,k,n,Q)
    t := 0;
    for dN in Divisors(N) do
        N_prime := D*N div dN;
        ds := get_ds(D*N, Q, N_prime, n);
        for d in ds do
            n_p := n_prime(d, D*N, Q, N_prime, n);
            d_p := d_prime(d, D*N, Q, N_prime);
            dd_p := dd_prime(d, D*N, Q, N_prime, n);
            Q_p := Q_prime(D*N, Q, N_prime);
            // Should always be trivial as n is coprime to D*N
            // term := GCD(d_p, n);
            // term *:= MoebiusMu(dd_p);
            // t_d := TraceFormulaGamma0HeckeALNew(N_prime, k, n, GCD(Q, N_prime));
            // t +:= t_d * #Divisors(d);
            t +:= TraceFormulaGamma0HeckeALNew(N_prime, k, n, Q_p);
        end for;
    end for;
    return t;
end function;

intrinsic TraceDNewALFixed(D::RngIntElt,N::RngIntElt,k::RngIntElt,n::RngIntElt,W::SetEnum ) -> RngIntElt
    {}
    sum := 0;
    for w in W do
        sgn := (-1)^#PrimeDivisors(GCD(w,D));
        sum +:= sgn*TraceDNew(D, N, k, n, w);
    end for;
    sum *:= 1/#W;

    //1/#W*&+[TraceDNew(D, N, k, n, w) : w in W];
    
    return sum;
end intrinsic;

/*
function sum_n_powers_trace_formula(D, N, W, p, n)
    t_p_n := TraceDNewALFixed(D,N,2,p^n,W);
    if n eq 1 then
    return t_p_n;
    end if;
    t_p_n_2 := TraceDNewALFixed(D,N,2,p^(n-2),W);
    return t_p_n - p*t_p_n_2;
end function;
*/

// Returns false if X is not subhyperelliptic
// If returns true we don't know (compare point counts)

intrinsic CheckHeckeTrace(X ::ShimuraQuot) ->BoolElt
    {}
    assert X`g ge 3;
    ws := [w : w in X`W | w ne 1];
    ps := [p : p in PrimesUpTo(4*X`g^2) | X`D*X`N mod p ne 0];
    for p in ps do
        v_max := Floor(Log(p,4*X`g^2));
        tps := AssociativeArray([-1..v_max]);
        tps[-1] := 0;
        for v in [1..v_max] do
            tps[v] := TraceDNewALFixed(X`D, X`N, 2, p^v, X`W);
        end for;
        if (v_max gt 1) then
            tps[0] := TraceDNewALFixed(X`D, X`N, 2, 1, X`W);
            assert tps[0] eq X`g;
        end if;
        for v in [1..v_max] do
            trace_frob_n := tps[v] - p*tps[v-2];
            num_pts := p^v  + 1 - trace_frob_n;
            if (num_pts gt 2*(1+p^v)) then
                print "p, v = ", p, v;
                return false;
            end if;
        end for;
    end for;
    return true;
end intrinsic;

intrinsic FilterByTrace(~curve_list::SeqEnum)
    {}
    lut := AssociativeArray();
    for i->X in curve_list do
	if assigned X`IsSubhyp then
            continue;
	end if;
	vprint ShimuraQuotients, 2: "i = ", i;
	if not CheckHeckeTrace(X) then
            curve_list[i]`IsSubhyp := false;
            curve_list[i]`IsHyp := false;
	end if;
    end for;
end intrinsic;

intrinsic CountFixedPointsOnQuotient(w ::RngIntElt, c ::ShimuraQuot ) -> RngIntElt
    {}
    return (1/#c`W) * &+[NumFixedPoints(c`D, c`N, al_mul(w, m, c`N*c`D)) : m in c`W];
end intrinsic;

// If X_0*(N) is not P1 and is subhyperelliptic
// (so it is either elliptic or hyperelliptic)
// then any AL involution on X = X_0(N)/W is non-hyperelliptic
// and if X is hyperelliptic, has atmost four fixed points.
// Test returns false if X is non-hyperelliptic
// If true, X might be hyperelliptic
intrinsic TestALFixedPointsOnQuotient(X ::ShimuraQuot) -> BoolElt
    {}
    DN := X`D*X`N;
    ws := [d : d in Divisors(DN) | d notin X`W and (GCD(d, DN div d) eq 1)];
    for d in ws do
    fix := CountFixedPointsOnQuotient(d, X);
    if IsEven(X`g) and fix gt 2 then
        return false;
    elif IsOdd(X`g) and fix gt 4 then
        return false;
    end if;
    end for;
    return true;
end intrinsic;

intrinsic FilterByALFixedPointsOnQuotient(~curves::SeqEnum)
    {}
    for lc->c in curves do
    if (assigned c`IsSubhyp) and c`IsSubhyp then
        continue;
    end if;
    // if testALFixedPointsOnQuotient(c) then
        // Include(~passed_test, c);
    if not TestALFixedPointsOnQuotient(c) then
        curves[lc]`IsSubhyp := false;
        curves[lc]`IsHyp := false;
    end if;
    // lc +:= 1;
    if (lc mod 100 eq 0) then
        print "lc = ", lc;
    end if;
    end for;
end intrinsic;

// implementing Proposition 6 of [FH]
// returns the W for which X_0(D,N)/W is not hyperelliptic
intrinsic TestComplicatedALFixedPointsOnQuotient(D::RngIntElt,N::RngIntElt) -> SetEnum
    {}
    cond_2 := [N2 : N2 in Divisors(N) | ClassNumber(-4*N2) mod 3 eq 0];
    // print "cond_2 = ", cond_2;
    cond_1 := [N2 : N2 in cond_2 | (N2 mod 4 ne 3) or
				   ((N2 mod 8 eq 3) and IsEven(N)) or
				   ((N2 mod 8 eq 7) and IsEven(D))];
    // print "cond_1 = ", cond_1;
    num_fixed := [NumFixedPoints(D, N, N2) : N2 in cond_1];
    good_idxs := [i : i in [1..#num_fixed] | (num_fixed[i] ne 0) and
		  (num_fixed[i] mod 3 eq 0) and
		  (PrimeDivisors(num_fixed[i]) subset [2,3]) ];
    N2s := [cond_1[i] : i in good_idxs];
    // print "N2s = ", N2s;
    nfixed := [num_fixed[i] : i in good_idxs];
    omega := Omega(D*N);
    Ws := ALSubgroups(D*N);
    // !! TODO - Could reuse the data we already have
    Ws := [W[1] : W in Ws | GenusShimuraCurveQuotient(D, N, W[1]) ge 3];
    non_hyp := {};
    for i->N2 in N2s do
	r := omega - Valuation(nfixed[i], 2);
	Ws_N2 := [W : W in Ws | (#W eq 2^(omega-r)) and (N2 notin W)];
/*
	if (N2 eq 195) then
	    print "N2 = ", 195;
	    print "Ws = ", Ws;
	end if;
*/
	for W in Ws do
	    is_non_hyp := false;
	    N1s := [N1 : N1 in Divisors(N) | (N1 notin W) and (N1 ne N2)];
	    N1s := [N1 : N1 in N1s | NumFixedPoints(D, N, N1) eq 2^(omega-r)];
/*
	    if (N2 eq 195) and ({6, 10, 26} subset W) then
		print "N1s = ", N1s;
	    end if;
*/
	    for N1 in N1s do
		a := AssociativeArray();
		for w in W do
		    a[al_mul(N1, w,D*N)] := w;
		end for;
		/*
		if (N2 eq 195) and ({6, 10, 26} subset W) then
		    print "N1 = ", N1;
		    for k in Keys(a) do
			print "a[", k, "] = ", a[k];
		    end for;
		end if;
*/
		for w in W do
		    N_prime := al_mul(N2, w, D*N);
		    //if (N2 eq 195) and ({6, 10, 26} subset W) then
			// print "w = ", w;
			// print "N2 * w = ", N_prime;
		    //end if;
		    if IsDefined(a, N_prime) then
			/*
			print "N_prime = ", N_prime;
			print "N_double_prime = ", a[N_prime];
			print "N_triple_prime = ", w;
			print "h(-4N_1) = ", ClassNumber(-4*N1);
			print "h(-4N_2) = ", ClassNumber(-4*N2);
		       */
			Include(~non_hyp, W);
			Ws := [WW : WW in Ws | WW ne W]; 
			is_non_hyp := true;
			break;
		    end if;
		end for;
		if is_non_hyp then
		    break;
		end if;
	    end for;
	end for;
    end for;
    return non_hyp;
end intrinsic;

intrinsic UpdateByGenus(~curves :: SeqEnum)
    {}
    for i in [1..#curves] do
    if (curves[i]`g eq 0) then
        curves[i]`IsP1 := true;
        curves[i]`IsEC := false;
        curves[i]`IsHyp := false;
        // check the ones with hyperelliptic AL involution
        if assigned curves[i]`CoveredBy then
        for cover in curves[i]`CoveredBy do
            curves[cover]`IsSubhyp := true;
            if (curves[cover]`g ge 2) then
            curves[cover]`IsHyp := true;
            end if;
        end for;
        end if;
    end if;
    if (curves[i]`g eq 1) then
        curves[i]`IsEC := true;
        curves[i]`IsHyp := false;
    else
        curves[i]`IsEC := false;
    end if;
    if (curves[i]`g eq 2) then
        curves[i]`IsHyp := true;
    end if;
    if (curves[i]`g le 2) then
        curves[i]`IsSubhyp := true;
    end if;
    end for;
end intrinsic;

intrinsic FilterByComplicatedALFixedPointsOnQuotient(~curves::SeqEnum )
    {}
    DN_pairs := {<c`D, c`N> : c in curves | not assigned c`IsSubhyp};
    DN_pairs := [pair : pair in DN_pairs];

    lut := AssociativeArray();
    for i in [1..#curves] do
    c := curves[i];
    lut[<c`D, c`N, c`W>] := i;
    end for;

    for lc->DN in DN_pairs do
    D, N := Explode(DN);
    Ws := TestComplicatedALFixedPointsOnQuotient(D, N);
    for W in Ws do
        if not IsDefined(lut, <D,N,W>) then
        continue;
        end if;
        curves[lut[<D,N,W>]]`IsSubhyp := false;
        if (curves[lut[<D,N,W>]]`g ge 2) then
        curves[lut[<D,N,W>]]`IsHyp := false;
        end if;
    end for;
    if (lc mod 100 eq 0) then
        vprint ShimuraQuotients, 2: "lc = ", lc;
    end if;
    end for;
end intrinsic;

intrinsic DownwardClosure(~curves::SeqEnum)
    {}
    for c in curves do
    if (assigned c`IsSubhyp) and c`IsSubhyp then
        for covered in c`Covers do
        curves[covered]`IsSubhyp := true;
        if curves[covered]`g eq 0 then
            curves[covered]`IsP1 := true;
        elif curves[covered]`g eq 1 then
            curves[covered]`IsEC := true;
        else curves[covered]`IsHyp := true;
        end if;
        end for;
    end if;
    end for;
end intrinsic;

intrinsic UpwardClosure(~curves::SeqEnum)
    {}
    for c in curves do
    if (assigned c`IsSubhyp) and (not c`IsSubhyp) then
        for cover in c`CoveredBy do
        curves[cover]`IsSubhyp := false;
        curves[cover]`IsHyp := false;
        end for;
    end if;
    end for;
end intrinsic;

intrinsic Genus3CoversGenus2(~curves::SeqEnum)
    {}
    for c in curves do
    if c`g eq 2 then
        for cover in c`CoveredBy do
        if curves[cover]`g eq 3 then
            curves[cover]`IsSubhyp := true;
            curves[cover]`IsHyp := true;
        end if;
        end for;
    end if;
    end for;
end intrinsic;

intrinsic VerifyHHTable1(curves::SeqEnum)
    {}
    Table1 := AssociativeArray([3..19]);
    Table1[3] := {97, 109, 113, 127, 128, 136, 139, 144, 149, 151,
          152, 162, 164, 169, 171, 175, 178, 179, 183, 185,
          187, 189, 194, 196, 203, 207, 217, 234, 236, 240,
          245, 246, 248, 249, 252, 258, 270, 282, 290, 294,
          295, 303, 310, 312, 315, 318, 329, 348, 420, 429,
          430, 455, 462, 476, 510};
    Table1[4] := {137, 148, 160, 172, 173, 176, 199, 200, 201, 202,
          214, 219, 224, 225, 228, 242, 247, 254, 259, 260,
          261, 262, 264, 267, 273, 275, 280, 300, 305, 306,
          308, 319, 321, 322, 335, 341, 342, 345, 350, 354,
          355, 366, 370, 374, 385, 399, 426, 434, 483, 546,
          570};
    Table1[5] := {157, 181, 192, 208, 212, 216, 218, 226, 235, 237,
          250, 253, 278, 279, 302, 323, 364, 371, 377, 378,
          391, 396, 402, 406, 410, 414, 418, 435, 438, 440,
          442, 444, 465, 494, 495, 595, 630, 714, 770, 798};
    Table1[6] := {163, 197, 211, 244, 265, 272, 274, 291, 297, 301,
          325, 336, 340, 470, 506, 561, 564, 690, 780, 858};
    Table1[7] := {193, 232, 268, 288, 296, 298, 309, 360, 372, 450,
          456, 460, 474, 492, 498, 504, 518, 558, 582, 660,
          870, 924};
    Table1[8] := {292, 408, 468, 480, 534, 540, 552, 606, 930, 966,
          990, 1020};
    Table1[9] := {516, 522, 528, 1110, 1140};
    Table1[10] := {600, 840, 1050, 1230, 1290};
    Table1[11] := {};
    Table1[12] := {2310};
    Table1[13] := {1260};
    Table1[14] := {2730};
    Table1[15] := {1470};
    Table1[16] := {};
    Table1[17] := {};
    Table1[18] := {};
    Table1[19] := {1680};
    // We add here a list of discrepancies
    // This is because the formula in [FH99] is slightly better than
    // the one in [HH96] accounting for all the cusps in the quotient
    Table1[3] diff:= {128};
    Table1[5] diff:= {495};
    Table1[6] diff:= {272, 297};
    Table1[7] diff:= {288, 296};
    // !! This is weird - N = 1170 should be appearing in Table 1,
    // but for some reason it does not.
    Table1[12] join:= {1170};
    assert Maximum([c`g : c in curves | c`D eq 1]) eq 19;
    for g in [3..19] do
    genus_g := {c`N : c in curves | (c`D eq 1) and (c`g eq g)};
    assert Table1[g] eq genus_g;
    end for;
end intrinsic;

intrinsic GetHHTable2() -> SeqEnum
    {}
    Table2 := [[] : g in [1..19]];
    Table2[3] := [ 127, 136, 144, 152, 162, 164, 171, 175, 183, 185,
           194, 196, 207, 217, 234, 240, 246, 252, 258, 270,
           282, 290, 294, 310, 312, 315, 318, 348, 420, 462,
           476, 510 ];
    Table2[4] := [ 160, 176, 264, 280, 300, 306, 322, 342, 345, 370,
           546, 570 ];
    Table2[5] := [ 216, 279, 396, 630, 714 ];
    Table2[6] := [ 336, 690 ];
    Table2[7] := [ 360, 450 ];
    Table2[10] := [840];
    Table2[12] := [2310];
    // This seems to be removed by considering p = 11, v = 2. Check!
    // Table2[19] := [1680];
    return Table2;
end intrinsic;

function GetModularByGenus(curves)
    g_max := Maximum([X`g : X in curves]);
    by_genus := [[X`N : X in curves | X`D eq 1 and
                      not assigned X`IsSubhyp and
                      X`g eq g] : g in [1..g_max]];
    return by_genus;
end function;

intrinsic VerifyHHTable2(starcurves::SeqEnum)
    {}
    Table2 := GetHHTable2();
    by_genus := GetModularByGenus(starcurves);
    assert Table2 eq by_genus;
end intrinsic;

intrinsic VerifyHHProposition1(starcurves::SeqEnum)
    {}
    Table2 := GetHHTable2();
    by_genus := GetModularByGenus(starcurves);
    Table2[3] := [N : N in Table2[3] | N ne 194];
    Table2[4] := [N : N in Table2[4] | N ne 546];
    assert Table2 eq by_genus;
end intrinsic;

// Apply the observation from [HH96] Proposition 1,
// that if X_0^*(D, pN) and X_0^*(D, N) have the same genus,
// they will be isomorphic in characteristic p
intrinsic HHProposition1(~curves::SeqEnum)
    {}
    lut_D := AssociativeArray();
    lut_DN := AssociativeArray();
    for X in curves do
    lut_DN[<X`D, X`N>] := X`CurveID;
    if not IsDefined(lut_D, X`D) then
        lut_D[X`D] := [];
    end if;
    lut_D[X`D] := Append(lut_D[X`D], X`N);
    end for;
    for i->X in curves do
    if (assigned X`IsSubhyp) and (not X`IsSubhyp) then
        Ns := lut_D[X`D];
        ps := [N div X`N : N in Ns | (N mod X`N eq 0) and
                     IsPrime(N div X`N)];
        for p in ps do
        if IsDefined(lut_DN, <X`D, p*X`N>) then
            other := lut_DN[<X`D, p*X`N>];
            if X`g eq curves[other]`g then
            curves[other]`IsSubhyp := false;
            curves[other]`IsHyp := false;
            end if;
        end if;
        end for;
    end if;
    end for;
end intrinsic;

// Get a hyperelliptic curve from q-expansions
function IsHyperelliptic(qexps, prec)
    R<q> := Universe(qexps);
    K := BaseRing(R);
    fs := [f + O(q^prec) : f in qexps];
    g := #fs;
    T, E := EchelonForm(Matrix([&cat[Eltseq(x)
                     : x in AbsEltseq(f)] : f in fs]));
    fs := [&+[E[j][i]*fs[i] : i in [1..g]] : j in [1..g]];
    x := fs[g-1] / fs[g];
    y := q * Derivative(x) / fs[g];
    mons := [x^i : i in [0..2*g+2]] cat [-y^2];
    denom := q^(-(2*g+2)*Valuation(x));
    f_mons := [denom*m + O(q^AbsolutePrecision(y)) : m in mons];
    ker := Kernel(Matrix([AbsEltseq(f : FixedLength) : f in f_mons]));
    if (Dimension(ker) eq 0) then
    return false, _;
    end if;
    if Dimension(ker) gt 1 then
    error "Too many relations, not enough precision!";
    end if;
    ker_b := Basis(ker)[1];
    ker_b /:= -ker_b[2*g+4];
    R<x> := PolynomialRing(K);
    poly := &+[ker_b[i+1]*x^i : i in [0..2*g+2]];
    X := HyperellipticCurve(-poly);
    return true, X, fs;
end function;

procedure UpdateIsoStatus(~c1, ~c2)
    M := c1`N;
    WMs := c1`W;
    N := c2`N;
    WNs := c2`W;
    D := c1`D;

    if assigned(c1`IsSubhyp) and not assigned(c2`IsSubhyp) then
        c2`IsSubhyp := c1`IsSubhyp;
        if assigned c1`IsHyp then
            c2`IsHyp := c1`IsHyp;
        end if;
        vprintf ShimuraQuotients, 2: "Found new isomorphism between level %o with ALs %o and level %o with ALs %o at disc %o.\n", N, WNs, M, WMs, D;
    elif assigned(c2`IsSubhyp) and not assigned(c1`IsSubhyp) then
        c1`IsSubhyp := c2`IsSubhyp;
        if assigned c2`IsHyp then
            c1`IsHyp := c2`IsHyp;
        end if;
        vprintf ShimuraQuotients, 2: "Found new isomorphism between level %o with ALs %o and level %o with ALs %o at disc %o.\n", N, WNs, M, WMs, D;
    elif assigned(c1`IsSubhyp) and assigned(c2`IsSubhyp) then
        assert assigned(c1`IsSubhyp) eq assigned(c2`IsSubhyp);
        vprintf ShimuraQuotients, 3: "Found isomorphism between level %o with ALs %o and level %o with ALs %o at disc %o.\n", N, WNs, M, WMs, D;
    elif not assigned(c1`IsSubhyp) and not assigned(c2`IsSubhyp) then
        vprintf ShimuraQuotients, 3: "Found (currently useless) isomorphism between level %o with ALs %o and level %o with ALs %o at disc %o.\n", N, WNs, M, WMs, D;
    end if;
end procedure;


intrinsic UpdateByIsomorphisms(~curves::SeqEnum)
    {}

    lut := AssociativeArray();
    for i in [1..#curves] do
        c := curves[i];
        lut[<c`D, c`N, c`W>] := i;
    end for;

    for i in [1..#curves] do
        curve := curves[i];
        M := curve`N;
        WMs := curve`W;
        badcurve := false; //check all ALs belong to the right level
        for w in WMs do
            if w mod 2 eq 0 then
                badcurve := true;
            end if;
        end for;
        if badcurve then
            continue;
        end if;
        D := curve`D;
        if IsEven(M) and GCD(2, M div 2) eq 1 then
            N := 2*M;
            WNs := Include(WMs, 4);
            WNs := AllALsFromGens(WNs, N*D);
            if <D,N,WNs> in Keys(lut) then 
                curve2 := curves[lut[<D, N, WNs>]];
                UpdateIsoStatus(~curve, ~curve2);
            end if;
        end if;
	
        function eps(Ni)
            if (Ni eq 1 mod 3) or ((Ni mod 9 eq 0) and (Ni div 9) mod 9 eq 1) then
                return 1;
            else
                return 0;
            end if;
        end function;

        if M mod 9 eq 0 and GCD(9, M div 9) eq 1 then
            WNs := {};
            for Ni in WMs do
                e:= eps(Ni);
                if e ne 0 then
                    Include(~WNs, al_mul(Ni, 9, N*D));
                    WNs := AllALsFromGens(WNs, N*D);
                else
                    Include(~WNs, Ni);
                    WNs := AllALsFromGens(WNs, N*D);
                end if;
            end for;
            if <D,N,WNs> in Keys(lut) then 
                curve2 := curves[lut[<D, N, WNs>]];
                UpdateIsoStatus(~curve, ~curve2);
            end if;
        end if;
    end for;

end intrinsic;
// Although this is not a canonical model over Q,
// it still yields a geometrical model over C,
// so we can use the q-expansions to check
// now using Eran's magma hack to allow for
// D-new modular forms where D is not a prime
// Returns whether the curve is geometrically hyperelliptic or not
function qExpansionCheck(X)
    assert X`g ge 3;
    assert X`D eq 1; // At the moment this only makes sense for modular curves
    ws := [w : w in X`W | w ne 1];
    mfs := NewSubspace(CuspForms(X`D*X`N,2), X`D);
    mfs := BaseChange(mfs, Rationals());
    als := [AtkinLehnerOperator(mfs,w) : w in ws];
    V := VectorSpace(mfs);
    for al in als do
    V := V meet Kernel(al-1);
    end for;
    assert X`g eq Dimension(V);
    BV := BasisMatrix(V);
    prec := 4*X`g^2+8*X`g-20+1;
    qexps := [qExpansion(f, prec) : f in Basis(mfs)];
    Rq<q> := Universe(qexps);
    coeff_mat := Matrix([AbsEltseq(qexp) : qexp in qexps]);
    qexps_V := [Rq!Eltseq(r) : r in Rows(BV*coeff_mat)];
    return IsHyperelliptic(qexps_V, prec);
end function;

procedure Filter_qExpansion(~curves)
    for i->X in curves do
	if not assigned X`IsSubhyp then
            curves[i]`IsHyp := qExpansionCheck(X);
            curves[i]`IsSubhyp := curves[i]`IsHyp;
	end if;
    end for;
end procedure;


intrinsic CheckProgress(curves :: SeqEnum) -> FldRatElt, RingIntElt
    {}
    total := #curves;
    done := Rationals()!0;
    for c in curves do
        if assigned c`IsSubhyp then
            done +:= 1;
        end if;
    end for;
    return done/total, total - done;
end intrinsic;

intrinsic IsStarCurve(X ::ShimuraQuot) -> BoolElt
    {}
    if #X`Covers eq 0 then return true;
    else return false;
    end if;

end intrinsic;


intrinsic NumWeierstrassPoints(X :: ShimuraQuot, curves::SeqEnum) -> RngIntElt
    {}
    g := X`g;
    WPs := 0;
    for id in X`Covers do
        C := curves[id];
        gq := C`g;
        if gq eq Floor(g/2) then
            continue;
        else
            ws := C`W diff X`W;
            WPs +:= &+[NumFixedPoints(X`N, X`D, w) : w in ws]; 
        end if;
    end for;
    return WPs;
end intrinsic;

intrinsic FilterByWSPoints(~curves::SeqEnum)
    {}
    for i->c in curves do
        if assigned curves[i]`IsSubhyp then continue; end if;
        ws := NumWeierstrassPoints(c, curves);
        g := c`g;
        if ws gt 2*g + 2 then
            curves[i]`IsSubhyp := false;
            curves[i]`IsHyp := false;
        end if;
    end for;
end intrinsic;

//this shouldn't be necessary now that I fixed the code, but sometimes we were accidentally updating subhyp without hyp
intrinsic updatehypfromsubhyp(~curves::SeqEnum)
    {}
    for i->c in curves do
        if assigned curves[i]`IsSubhyp and not assigned curves[i]`IsHyp then
            g := curves[i]`g;
            if g eq 1 then
                curves[i]`IsEC := curves[i]`IsSubhyp;
            elif g eq 0 then
                curves[i]`IsP1 := curves[i]`IsSubhyp;
            else
                curves[i]`IsHyp := curves[i]`IsSubhyp;
            end if;
        end if;
    end for;
end intrinsic;

intrinsic NumberOfEllipticPoints(X::ShimuraQuot, q::RngIntElt) -> RngIntElt
{Return the number of elliptic points of order q on X.}
    require (q gt 1) : "Elliptic points of order %o are not well-defined.", q;
    delta_2 := (2 in X`W) select 1 else 0;
    delta_3 := (3 in X`W) select 1 else 0;
    e2 := NumberOfEllipticPoints(X`D, X`N, 2);
    e3 := NumberOfEllipticPoints(X`D, X`N, 3);
    if q eq 2 then
        F_W := &+[NumFixedPoints(X`D, X`N, w) : w in X`W | w ne 1];
        numerator := 2*F_W + (1-3*delta_2)*e2 - 2*delta_3*e3;
        require (numerator % #X`W eq 0) : "Error counting elliptic points, getting non-integral result.";
        return numerator div #X`W;
    elif q eq 3 then
        numerator := (1-delta_3)*e_3;
    elif q eq 4 then
        numerator := 2*delta_2*e_2;
    elif q eq 6 then
        numerator := 2*delta_3*e_3;
    else    
        numerator := 0;
    end if;
    require ((numerator % #X`W) eq 0) : "Error counting elliptic points, getting non-integral result.";
    return numerator div #X`W;
end intrinsic;

intrinsic CheckUniversalCover(X::ShimuraQuot) -> BoolElt
{Returns true if H, the upper half plane, is the universal cover of X.}
    // If Gamma_W has no elliptic points, 
    // then any automorphism of the curve is a Mobius transformation.
    // If the level does not have any square factor dividing 24, they are all Atkin-Lehners.
    return &+[NumberOfEllipticPoints(X, q) : q in [2,3,4,6]] eq 0;
end intrinsic;


//procedure code_we_ran()

// [FH] Furumoto, Hasegawa, "Hyperelliptic Quotients of Modular Curves X_0(N)"
//
// [HH] Hasegawa, Hashimoto, "Hyperelliptic modular curves X_0^*(N)
// with square-free levels"
//
// [Ogg] Real points on Shimura Curves
