// File for determining the hyperelliptic quotients of Shimura curves
// of the form X_0(D,N)

// Committed to Geometrically Hyperelliptic curves 

import "TraceFormula.m" : TraceFormulaGamma0HeckeAL,
                          TraceFormulaGamma0HeckeALNew;

// A record format to save information we care about for each of the curves

CurveQuot := recformat< D : RngIntElt, 
			N : RngIntElt,
			W : SetEnum,
			g : RngIntElt,
			curve_id : RngIntElt, 
			covered_by : SetEnum,			
			covers : SetEnum,
			is_p1 : BoolElt, 
			is_ec : BoolElt, 
			is_hyp : BoolElt,
			is_subhyp : BoolElt>;

// D - Discriminant of Quaternion algebra
// N - Level of Eichler order
// W - set of d | DN such that the group generated by w_d,
// the corresponding Atkin-Lehner involutions, is the group we quotient by
// g - Genus of the quotient
// curve_id - a unique identifier
// covered_by - curve_ids of the curves directly covering it
// covers - curve_ids of the curves it is directly covering
// is_p1 - f isomorphic to P1 (geom.), g = 0
// is_ec - if elliptic curve (geom.), g = 1
// is_hyp - if hyperelliptic (neither elliptic, nor p1)
// is_subhyp - if subhyperelliptic (i.e. any of the above)


// Lower and upper bounds for number of points in reduction mod p, 
// scaled by 12/p-1, see [HH]

function Omega(n)
    return #PrimeDivisors(n);
end function;

function FirstPrimes(n)
    ps := PrimesUpTo(1+Ceiling(n*(Log(n+1)+Log(Log(n+1)))));
    assert #ps ge n;
    return ps[1..n];
end function;

function LowerBoundD(D)
    return EulerPhi(D)/ 2^Omega(D);
end function;

function LowerBoundN(N)
    ps := PrimeDivisors(N);
    if N eq 1 then
    	c_N := 1;
   	else 
    	c_N := N * &*[ 1 + 1/p : p in ps];
    end if;
    return c_N / 2^Omega(N);
end function;

function LowerBound(D, N, p: lb:=false)
	if lb cmpeq false then
    	lb := LowerBoundD(D)*LowerBoundN(N);
	end if;
    if D eq 1 then
		h := Maximum([h : h in [ 1, 2, 3, 4, 6, 8, 12, 24 ] | N mod h^2 eq 0]);
		h2 := GCD(h,8); h3 := GCD(h,3);
		cond2 := IsEven(h2) and (N mod h2^2 eq 0) and
			 (GCD(h2^2, N div h2^2) eq 1);
		s2 := cond2 select 3/4 else 1;
		cond3 := (h3 eq 3) and Valuation(N, 3) eq 2;
		s3 := cond3 select 2/3 else 1;
		s := s2*s3;
		lb +:= 12*h*s/(p-1);
    end if;
    return lb;
end function;

function UpperBound(p : Geometric := true)
    // We use the fact that the geometric gonality is 2
    // so gonality over Q (hence also over F_p) is at most 4
    gonality := 2;
    /* Not needed in the hyperelliptic case, because of [Poonen, Thm 2.5(i)]
    if Geometric then
	gonality := gonality^2;
    end if;
    */ 
    return 12*gonality*(1+p^2)/(p-1);
end function;

function MinimalNumberOfALinQuotient(D, N)
    ps := PrimeDivisors(N);
    c_D := EulerPhi(D);
    c_N := N * &*[Rationals() | 1 + 1/p : p in ps];
    p := 2;
    while (N mod p eq 0) do
	p := NextPrime(p);
    end while;
    return Maximum(0,Ceiling(Log(2, (c_D * c_N) / UpperBound(p))));
end function;

procedure VerifyBound(r)
    ps := FirstPrimes(r+1);
    assert LowerBoundN(&*ps[1..r]) gt UpperBound(ps[r+1] :
						 Geometric := false);
    assert LowerBoundD(&*ps[1..r]) gt UpperBound(ps[r+1]);
end procedure;

function GetLargestPrimeIndex()
    p := 1;
    prod := 1;
    LB := 1;
    UB := 1;
    r := -1;
    while (LB le UB) do
	prod *:= p;
	p := NextPrime(p);
	LB := LowerBoundD(prod);
	UB := UpperBound(p);
	r +:= 1;
    end while;
    VerifyBound(r);
    return r;
end function;

function FindMaximalN(r)
    ps := FirstPrimes(r);
    return Floor(UpperBound(ps[r])*2^(r-1));
end function;

// Using https://math.stackexchange.com/questions/301837/is-the-euler-phi-function-bounded-below EEDDIITT -> TODO: Find a reference
function FindMaximalD(r)
    ps := FirstPrimes(r);
    ub := Ceiling(UpperBound(ps[r]));
    C := 2^(r-1)*ub;
    p := 2;
    prev := Infinity();
    bound := Infinity();
    A := p;
    RR := RealField();
    r := 1;
    while (bound le prev) do
	p := NextPrime(p);
	delta := RR!(1 - Log(p-1) / Log(p));
	A *:= p;
	r +:= 1;
	prev := bound;
	bound := Ceiling(A*(C/EulerPhi(A))^(1/(1-delta)));
	// print "bound = ", bound;
    end while;
    return bound; //, r, A;
end function;

// At the moment, we restrict to D and N being coprime
// Find all curves X_0*(D,N) which might be subhyperelliptic
function FindPairs(r : Coprime := true)
    pairs := [];
    // N0 := FindMaximalN(r);
    ps := FirstPrimes(r);
    ub := Ceiling(UpperBound(ps[r]));
    C := 2^(r-1)*ub;
    D0 := FindMaximalD(r);
    // Ds := [D : D in [1..D0] | IsSquarefree(D) and IsEven(Omega(D))];
    Ds := [D : D in [1..D0] | MoebiusMu(D) eq 1];  

    // stores LowerBoundN on [1..C]
    lNs := [LowerBoundN(N) : N in [1..C]];
    for D in Ds do
    	lD := LowerBoundD(D);
		// print "D = ", D;
		// Nmax := Floor(N0 / EulerPhi(D));
		Nmax := Ceiling(C / EulerPhi(D));
		Ns := [1..Nmax];	
		if Coprime then
		    Ns := [N : N in Ns | GCD(D,N) eq 1];
		end if;

		for N in Ns do
		    /*
		    if (N mod 1000 eq 0) then
			print "N =", N;
		    end if;
		   */
		    p := 2;
		    while (N mod p eq 0) do
			p := NextPrime(p);
		    end while;
		    if D eq 1 then 
		    	if lD*lNs[N] le UpperBound(p) then
			    	W := {d : d in Divisors(D*N) | GCD(d, (D*N) div d) eq 1};
					Append(~pairs, rec<CurveQuot | D := D, N := N, W := W >);
				end if;
			else 
		    	if (LowerBound(1, N, p) le UpperBound(p)) then
					W := {d : d in Divisors(D*N) | GCD(d, (D*N) div d) eq 1};
					Append(~pairs, rec<CurveQuot | D := D, N := N, W := W >);
				end if;
		    end if;
		end for;
    end for;
    return pairs;
end function;

// 2 corresponds to cusps, 3, 4
function NumberOfEllipticPoints(D, N, order)
    if order eq 2 then
	if D eq 1 then
	    return &+[EulerPhi(GCD(d, N div d)) : d in Divisors(N)];
	else
	    return 0;
	end if;
    end if;
    if order eq 4 then
	Q := 4;
    end if;
    if order eq 3 then 
	Q := 9;
    end if;
    if (N mod Q eq 0) then
	return 0;
    end if;
    primesD := PrimeDivisors(D);
    primesN := PrimeDivisors(N);
    e_D := &*[Integers() | 1 - KroneckerSymbol(-order, p) : p in primesD]; 
    e_N := &*[Integers() | 1 + KroneckerSymbol(-order, p) : p in primesN];
    return e_D * e_N;
end function;

function GenusShimuraCurve(D, N)
    phiD := EulerPhi(D);
    primes := PrimeDivisors(N);
    P1N := Floor(N * &*[Rationals() | 1 + 1/p : p in primes]);
    g := 1 + phiD * P1N / 12;
    e := AssociativeArray();
    for h in [2,3,4] do
	e[h] := NumberOfEllipticPoints(D, N, h);
	g -:= e[h] / h;
    end for;
    assert IsIntegral(g);
    return Floor(g);
end function;
    
function PsiOgg(p, n)
    if (n eq 1) then
	return 1;
    end if;
    is_prime_power, q, k := IsPrimePower(n);
    if (is_prime_power) then
	return ((q eq p) select Floor(p^k *(1 + 1/p)) else 1);
    end if;
    fac := Factorization(n);
    return &*[Integers() | PsiOgg(p, pe[1]^pe[2]) : pe in fac];
end function;

function LegendreSymbol(R, p)
    f := Conductor(R);
    if (f mod p eq 0) then
	return 1;
    end if;
    ZF := MaximalOrder(R);
    return KroneckerCharacter(Discriminant(ZF))(p);
end function;

// Here R is the quadratic order and 
// O is a fixed quaternion Eichler order of level F in 
// the quaternion algebra B of discriminant D. 
// based on Theorem 2 in [Ogg]
function NuOgg(p, R, D, F)
    if (D mod p eq 0) then
	return 1 - LegendreSymbol(R, p);
    end if;
    if Valuation(F, p) eq 1 then
	return 1 + LegendreSymbol(R, p);
    end if;
    assert Valuation(F, p) ge 2;
    f := Conductor(R);
    ZF := MaximalOrder(R);
    chi := KroneckerCharacter(Discriminant(ZF));
    k := Valuation(f, p);
    K := Valuation(F, p);
    if (K ge 2*(1 + k)) then
	if (chi(p) eq 1) then
	    return 2*PsiOgg(p, f);
	end if;
	return 0;
    end if;
    if (K eq 1 + 2*k) then
	if (chi(p) eq 1) then
	    return 2*PsiOgg(p, f);
	end if;
	if (chi(p) eq 0) then
	    return p^k;
	end if;
	assert chi(p) eq -1;
	return 0;
    end if;
    if (K eq 2*k) then
	return p^(k-1)*(p+1+chi(p));
    end if;
    if (K le 2*k - 1) then
	if IsEven(K) then
	    return p^(k div 2) + p^(k div 2 - 1);
	else
	    return 2*p^(k div 2);
	end if;
    end if;
    // Should not reach here
    assert false;
end function;

// Quotient by w_m, m divides DN, following [Ogg]

// The number of the fixed points of w_m on X_0(D,N) 
function NumFixedPoints(D, N, m)
    if (m eq 2) then
	orders := [MaximalOrder(QuadraticField(-1)), 
		   MaximalOrder(QuadraticField(-2))];
    elif (m mod 4 eq 3) then
	F := QuadraticField(-m);
	_, sqrt_minus_m := IsSquare(F!(-m));
	O := MaximalOrder(F);
	alpha := (1 + sqrt_minus_m)/2;
	orders := [sub<O | 1, alpha>, sub<O | 1, 2*alpha>];
    else
	F := QuadraticField(-m);
	_, sqrt_minus_m := IsSquare(F!(-m));
	O := MaximalOrder(F);
	orders := [sub<O | 1, sqrt_minus_m>];
    end if;
    e := 0;
    for R in orders do
	h := PicardNumber(R);
	// Using formula (4) in [Ogg]
	prod := &*[Integers() | 
		  NuOgg(p, R, D, N) : p in PrimeDivisors(D*N) | m mod p ne 0]; 
	e +:= h*prod;
    end for;
    if (D eq 1) and (m eq 4) then
	M := N div 4;
	num_fixed_cusps := &+[Integers() | 
			     EulerPhi(GCD(d, M div d)) : d in Divisors(M)];
	e +:= num_fixed_cusps;
    end if;
    return e;
end function;
    
function GenusShimuraCurveQuotientSingleAL(D, N, m)
    e := NumFixedPoints(D, N, m);
    g_big := GenusShimuraCurve(D, N);
    g := (g_big+1)/2 - e/4;
    assert IsIntegral(g);
    return Floor(g);
end function;

function GenusShimuraCurveQuotient(D, N, als)
    total_e := 0;
    for al in als do
	assert GCD(al, (D*N) div al) eq 1;
	if (al ne 1) then
	    total_e +:= NumFixedPoints(D, N, al);
	end if;
    end for;
    if #als eq 1 then 
	s := 0; 
    else
	is_prime_power, two, s := IsPrimePower(#als);
	assert is_prime_power and (two eq 2);
    end if;
    g_big := GenusShimuraCurve(D, N);
    g := 1 + (g_big - 1)/2^s - total_e/2^(s+1);
    assert IsIntegral(g);
    return Floor(g);
end function;

function exp_to_Q(e, N, ps)
    ZZ := Integers();
    return &*[ZZ | ps[i]^Valuation(N,ps[i]) : i in [1..#ps] | e[i] eq 1];
end function;

// Returns a sequence of tuples,
// containing the divisors in the group, the indices of maximal subgroups
// and the indices of minimal overgroups
function ALSubgroups(N)
    ZZ := Integers();
    Qs_in_grp := AssociativeArray();
    ps := PrimeDivisors(N);
    W := AbelianGroup([2 : i in [1..#ps]]);
    PW, PW_to_W := PermutationGroup(W);
    subs_PW := SubgroupLattice(PW);
    // subs_W := Subgroups(W);
    // Qs := {};
    Qs := [];
    // for H in subs_W do
    for i in [1..#subs_PW] do
	PH := subs_PW!i;
	H := PW_to_W(Group(PH));
	exps := {Eltseq(W!h) : h in H};
	grp := {exp_to_Q(e,N,ps) : e in exps};
	//Include(~Qs, grp);
	Append(~Qs, <grp, MaximalSubgroups(PH), MinimalOvergroups(PH)>);
    end for;
    return Qs;
end function;

function coversCurvesInList(c, curve_list : index := 0)
    D, N, als, g := Explode(c);
    relevant := [c2 : c2 in curve_list | (c2[1] eq D) and (c2[2] eq N) 
					 and (als subset c2[3])];
    for r in relevant do
	als_r := r[3];
	if (index ne 0) then
	    if #als_r eq index*#als then
		return true;
	    end if;
	else
	    return true;
	end if;
    end for;
    
    return false;
end function;

function coveredByCurvesInList(c, curve_list : index := 0)
    D, N, als, g := Explode(c);
    relevant := [c2 : c2 in curve_list | (c2[1] eq D) and (c2[2] eq N) 
					 and (c2[3] subset als)];
    for r in relevant do
	als_r := r[3];
	if (index ne 0) then
	    if #als eq index*#als_r then
		return true;
	    end if;
	else
	    // print r;
	    return true;
	end if;
    end for;
    
    return false;
end function;

function GetGenera(pairs)
    // No longer needed
    // Restrict first to coprime D and N
    // pairs := [p : p in pairs | GCD(p[1], p[2]) eq 1];
    genera := [];
    for i->p in pairs do
	D := p[1];
	N := p[2];
	// al_nums := [MinimalNumberOfALinQuotient(a[1], a[2]) : a in pairs];
	// min_num := al_nums[i];
	min_num := MinimalNumberOfALinQuotient(D,N);
	al_subs := ALSubgroups(D*N);
	al_subs_allowed := [S[1] : S in al_subs | #S[1] ge 2^min_num];
	for als in al_subs_allowed do
	    g := GenusShimuraCurveQuotient(D, N, als);
	    Append(~genera, <D, N, als, g>); 
	end for;
	print "i = ", i;
    end for;
    return genera;
end function;

procedure UpdateGenera(~curves)
    for i->c in curves do
	curves[i]`g := GenusShimuraCurveQuotient(c`D, c`N, c`W);
    end for;
    return;
end procedure;

function GetQuotientsAndGenera(curves)
    quots := [];
    for i->c in curves do
	min_num := MinimalNumberOfALinQuotient(c`D, c`N);
	al_subs := ALSubgroups(c`D*c`N);
	allowed_idxs := [j : j in [1..#al_subs] | #al_subs[j][1] ge 2^min_num];
	update_idxs := func < S | {Index(allowed_idxs, idx)
				   : idx in S | idx in allowed_idxs}>;
	allowed_subs := [<al_subs[j][1],
			  update_idxs(al_subs[j][2]),
			  update_idxs(al_subs[j][3])>
			 : j in allowed_idxs];
	cur_sz := #quots;
	for j->S in allowed_subs do
	    als := S[1];
	    g := GenusShimuraCurveQuotient(c`D, c`N, als);
	    quot := rec<CurveQuot | D := c`D, N := c`N, W := als,
				    g := g, curve_id := cur_sz + j,
				    covered_by := {cur_sz + idx : idx in S[2]},
				    covers := {cur_sz + idx : idx in S[3]}>;
	    Append(~quots, quot);
	end for;
	print "i = ", i;
    end for;
    return quots;
end function;

/*
function sum_n_powers(a_p, p, n)
    if n eq 0 then 
	return 2;
    end if;
    if n eq 1 then 
	return a_p;
    end if;
    return a_p*sum_n_powers(a_p, p, n-1) - p*sum_n_powers(a_p, p, n-2);
end function;
*/

// Can work faster if we first compute all the traces (half the work)
function sum_n_powers(mfs, p, n, BV)
    assert n ge 1;
    assert Level(mfs) mod p ne 0;
    T_p_n := HeckeOperator(mfs, p^n);
    T_p_n := ChangeRing(T_p_n, Rationals());
    T_p_n := Solution(BV, BV*T_p_n);
    if n eq 1 then 
	return Trace(T_p_n);
    end if;
    T_p_n_2 := HeckeOperator(mfs, p^(n-2));
    T_p_n_2 := ChangeRing(T_p_n_2, Rationals());
    T_p_n_2 := Solution(BV, BV*T_p_n_2);
    return Trace(T_p_n - p*T_p_n_2);
end function;

// At the moment only works on the whole space S_2(N)
function sum_n_powers_trace_formula(N, W, p, n)
    t_p_n := 1/#W*&+[TraceFormulaGamma0HeckeAL(N, 2, p^n, w) : w in W];
    if n eq 1 then
	return t_p_n;
    end if;
    t_p_n_2 := 1/#W*&+[TraceFormulaGamma0HeckeAL(N, 2, p^(n-2), w) : w in W];
    return t_p_n - p*t_p_n_2; 
end function;

function TraceDNew(D,N,k,n,Q)
    t := TraceFormulaGamma0HeckeALNew(D*N, k, n, Q);
    for p in PrimeDivisors(N) do
	N_prime := D*N div p;
	t +:= 2*TraceFormulaGamma0HeckeAL(N_prime, k, n, GCD(Q, N_prime));
    end for;
    return t;
end function;

function TraceDNewALFixed(D,N,k,n,W)
    return 1/#W*&+[TraceDNew(D, N, k, n, w) : w in W];
end function;

function sum_n_powers_trace_formula(D, N, W, p, n)
    t_p_n := TraceDNewALFixed(D,N,2,p^n,W);
    if n eq 1 then
	return t_p_n;
    end if;
    t_p_n_2 := TraceDNewALFixed(D,N,2,p^(n-2),W);
    return t_p_n - p*t_p_n_2; 
end function;

// Returns false if X is not subhyperelliptic
// If returns true we don't know (compare point counts)
				
function CheckHeckeTrace(X)
    // g := X[4];
    assert X`g ge 3;
    // N := X[2];
    // D := X[1];
    // ws := [w : w in X[3] | w ne 1];
    ws := [w : w in X`W | w ne 1];
    mfs := CuspidalSubspace(ModularSymbols(X`D*X`N,2,1));
    primes := PrimeDivisors(X`D);
    for p in primes do
	mfs := NewSubspace(mfs, p);
    end for;
    als := [AtkinLehnerOperator(mfs,w) : w in ws];
    V := VectorSpace(Rationals(), Dimension(mfs));
    for al in als do
	V := V meet Kernel(al-1);
    end for;
    BV := BasisMatrix(V);
    ps := [p : p in PrimesUpTo(4*X`g^2) | X`D*X`N mod p ne 0];
    for p in ps do
	v := 1;
	while (p^v le 4*X`g^2) do
	    trace_frob_n := sum_n_powers_trace_formula(X`D, X`N, X`W, p, v);
	    assert trace_frob_n eq sum_n_powers(mfs, p, v, BV);
	    num_pts := p^v+1 - trace_frob_n;
	    if (num_pts gt 2*(1+p^v)) then
		// print p, v;
		return false;
	    end if;
	    v +:= 1;
	end while;
    end for;
    return true;
end function;

procedure FilterByTrace(~curve_list)
    // This was just for upward closure, we can skip it now
    /*
    lut := AssociativeArray();
    for i->X in curve_list do
	// D, N, als, g := Explode(X);
	if not IsDefined(lut, <X`D,X`N>) then
	    lut[<X`D,X`N>] := [];
	end if;
	lut[<X`D,X`N>] := Append(lut[<X`D,X`N>], i);
    end for;
    failed := {};
    i := 1;
   */
    // while (i le #curve_list) do
    for i->X in curve_list do
	if assigned X`is_subhyp then
	    continue;
	end if;
	print "i = ", i;
//	X := curve_list[i];
	if not CheckHeckeTrace(X) then
	    // Include(~failed, i);
	    curve_list[i]`is_subhyp := false;
	    curve_list[i]`is_hyp := false;
	    // This was for upward closure, no longer needed
	    /*
	    D, N, als, g := Explode(X);
	    for j in lut[<D,N>] do
		if curve_list[j][3] subset als then
		    Include(~failed, j);
		end if;
	    end for;
	   */
	end if;
	/*
	i +:= 1;
	while ((i in failed) and (i le #curve_list)) do
	    i +:= 1;
	end while;
       */
	// end while;
    end for;
    return;
    //return [curve_list[i] : i in [1..#curve_list] | i notin failed];
end procedure;

function al_mul(w, m)
    ps := PrimeDivisors(w*m);
    wvals := Vector(GF(2), [Valuation(w, p) : p in ps]);
    mvals := Vector(GF(2), [Valuation(m, p) : p in ps]);
    wmvals := mvals + wvals;
    wm := &*[ps[i]^(Integers()!wmvals[i]) : i in [1..#ps]];
    return wm;
end function;

function CountFixedPointsOnQuotient(w, c)
    // D := c[1];
    // N := c[2];
    // W := c[3];
    return (1/#c`W) * &+[NumFixedPoints(c`D, c`N, al_mul(w, m)) : m in c`W];
end function;

// If X_0*(N) is not P1 and is subhyperelliptic
// (so it is either elliptic or hyperelliptic)
// then any AL involution on X = X_0(N)/W is non-hyperelliptic
// and if X is hyperelliptic, has atmost four fixed points.
// Test returns false if X is non-hyperelliptic
// If true, X might be hyperelliptic
function TestALFixedPointsOnQuotient(X)
    // D, N, W, g := Explode(c);
    DN := X`D*X`N;
    ws := [d : d in Divisors(DN) | d notin X`W and (GCD(d, DN div d) eq 1)];
    for d in ws do
	fix := CountFixedPointsOnQuotient(d, X);
	if IsEven(X`g) and fix gt 2 then
	    return false;
	elif IsOdd(X`g) and fix gt 4 then
	    return false;
	end if;
    end for;
    return true;
end function;

procedure FilterByALFixedPointsOnQuotient(~curves)
    for lc->c in curves do
	if (assigned c`is_subhyp) and c`is_subhyp then
	    continue;
	end if;
	// if testALFixedPointsOnQuotient(c) then
	    // Include(~passed_test, c);
	if not TestALFixedPointsOnQuotient(c) then
	    curves[lc]`is_subhyp := false;
	end if;
	// lc +:= 1;
	if (lc mod 100 eq 0) then
	    print "lc = ", lc;
	end if;
    end for;
    return;
end procedure;

// implementing Proposition 6 of [FH]
// returns the W for which X_0(D,N)/W is not hyperelliptic
function TestComplicatedALFixedPointsOnQuotient(D,N)
    cond_2 := [N2 : N2 in Divisors(N) | ClassNumber(-4*N2) mod 3 eq 0];
    // print "cond_2 = ", cond_2;
    cond_1 := [N2 : N2 in cond_2 | (N2 mod 4 ne 3) or
				   ((N2 mod 8 eq 3) and IsEven(N)) or
				   ((N2 mod 8 eq 7) and IsEven(D))];
    // print "cond_1 = ", cond_1;
    num_fixed := [NumFixedPoints(D, N, N2) : N2 in cond_1];
    good_idxs := [i : i in [1..#num_fixed] | (num_fixed[i] ne 0) and
		  (num_fixed[i] mod 3 eq 0) and
		  (PrimeDivisors(num_fixed[i]) subset [2,3]) ];
    N2s := [cond_1[i] : i in good_idxs];
    // print "N2s = ", N2s;
    nfixed := [num_fixed[i] : i in good_idxs];
    omega := Omega(D*N);
    Ws := ALSubgroups(D*N);
    // !! TODO - Could reuse the data we already have
    Ws := [W[1] : W in Ws | GenusShimuraCurveQuotient(D, N, W[1]) ge 3];
    non_hyp := {};
    for i->N2 in N2s do
	r := omega - Valuation(nfixed[i], 2);
	Ws_N2 := [W : W in Ws | (#W eq 2^(omega-r)) and (N2 notin W)];
/*
	if (N2 eq 195) then
	    print "N2 = ", 195;
	    print "Ws = ", Ws;
	end if;
*/
	for W in Ws do
	    is_non_hyp := false;
	    N1s := [N1 : N1 in Divisors(N) | (N1 notin W) and (N1 ne N2)];
	    N1s := [N1 : N1 in N1s | NumFixedPoints(D, N, N1) eq 2^(omega-r)];
/*
	    if (N2 eq 195) and ({6, 10, 26} subset W) then
		print "N1s = ", N1s;
	    end if;
*/
	    for N1 in N1s do
		a := AssociativeArray();
		for w in W do
		    a[al_mul(N1, w)] := w;
		end for;
		/*
		if (N2 eq 195) and ({6, 10, 26} subset W) then
		    print "N1 = ", N1;
		    for k in Keys(a) do
			print "a[", k, "] = ", a[k];
		    end for;
		end if;
*/
		for w in W do
		    N_prime := al_mul(N2, w);
		    //if (N2 eq 195) and ({6, 10, 26} subset W) then
			// print "w = ", w;
			// print "N2 * w = ", N_prime;
		    //end if;
		    if IsDefined(a, N_prime) then
			/*
			print "N_prime = ", N_prime;
			print "N_double_prime = ", a[N_prime];
			print "N_triple_prime = ", w;
			print "h(-4N_1) = ", ClassNumber(-4*N1);
			print "h(-4N_2) = ", ClassNumber(-4*N2);
		       */
			Include(~non_hyp, W);
			Ws := [WW : WW in Ws | WW ne W]; 
			is_non_hyp := true;
			break;
		    end if;
		end for;
		if is_non_hyp then
		    break;
		end if;
	    end for;
	end for;
    end for;
    return non_hyp;
end function;

procedure UpdateByGenus(~curves)
    for i in [1..#curves] do
	if (curves[i]`g eq 0) then
	    curves[i]`is_p1 := true;
	    // check the ones with hyperelliptic AL involution
	    if assigned curves[i]`covered_by then
		for cover in curves[i]`covered_by do
		    curves[cover]`is_subhyp := true;
		    if (curves[cover]`g ge 2) then
			curves[cover]`is_hyp := true;
		    end if;
		end for;
	    end if;
	end if;
	if (curves[i]`g eq 1) then
	    curves[i]`is_ec := true;
	end if;
	if (curves[i]`g eq 2) then
	    curves[i]`is_hyp := true;
	end if;
	if (curves[i]`g le 2) then
	    curves[i]`is_subhyp := true;
	end if;	
    end for;
    return;
end procedure;

procedure FilterByComplicatedALFixedPointsOnQuotient(~curves)
    DN_pairs := {<c`D, c`N> : c in curves | not assigned c`is_subhyp};
    DN_pairs := [pair : pair in DN_pairs];
    
    lut := AssociativeArray();
    for i in [1..#curves] do
	c := curves[i];
	lut[<c`D, c`N, c`W>] := i;
    end for;
    
    for lc->DN in DN_pairs do
	D, N := Explode(DN);
	Ws := TestComplicatedALFixedPointsOnQuotient(D, N);
	for W in Ws do
	    if not IsDefined(lut, <D,N,W>) then
		continue;
	    end if;
	    curves[lut[<D,N,W>]]`is_subhyp := false;
	    if (curves[lut[<D,N,W>]]`g ge 2) then
		curves[lut[<D,N,W>]]`is_hyp := false;
	    end if;
	end for;
	if (lc mod 100 eq 0) then
	    print "lc = ", lc;
	end if;
    end for;
    return;
end procedure;

procedure DownwardClosure(~curves)
    for c in curves do
	if (assigned c`is_subhyp) and c`is_subhyp then
	    for covered in c`covers do
		curves[covered]`is_subhyp := true;
	    end for;
	end if;
    end for;
    return;
end procedure;

procedure UpwardClosure(~curves)
    for c in curves do
	if (assigned c`is_subhyp) and (not c`is_subhyp) then
	    for cover in c`covered_by do
		curves[cover]`is_subhyp := false;
	    end for;
	end if;
    end for;
    return;
end procedure;

procedure Genus3CoversGenus2(~curves)
    for c in curves do
	if c`g eq 2 then
	    for cover in c`covered_by do
		if curves[cover]`g eq 3 then
		    curves[cover]`is_subhyp := true;
		    curves[cover]`is_hyp := true;
		end if;
	    end for;
	end if;
    end for;
    return;
end procedure;

procedure VerifyHHTable1(curves)
    Table1 := AssociativeArray([3..19]);
    Table1[3] := {97, 109, 113, 127, 128, 136, 139, 144, 149, 151,
		  152, 162, 164, 169, 171, 175, 178, 179, 183, 185,
		  187, 189, 194, 196, 203, 207, 217, 234, 236, 240,
		  245, 246, 248, 249, 252, 258, 270, 282, 290, 294,
		  295, 303, 310, 312, 315, 318, 329, 348, 420, 429,
		  430, 455, 462, 476, 510};
    Table1[4] := {137, 148, 160, 172, 173, 176, 199, 200, 201, 202,
		  214, 219, 224, 225, 228, 242, 247, 254, 259, 260,
		  261, 262, 264, 267, 273, 275, 280, 300, 305, 306,
		  308, 319, 321, 322, 335, 341, 342, 345, 350, 354,
		  355, 366, 370, 374, 385, 399, 426, 434, 483, 546,
		  570};
    Table1[5] := {157, 181, 192, 208, 212, 216, 218, 226, 235, 237,
		  250, 253, 278, 279, 302, 323, 364, 371, 377, 378,
		  391, 396, 402, 406, 410, 414, 418, 435, 438, 440,
		  442, 444, 465, 494, 495, 595, 630, 714, 770, 798};
    Table1[6] := {163, 197, 211, 244, 265, 272, 274, 291, 297, 301,
		  325, 336, 340, 470, 506, 561, 564, 690, 780, 858};
    Table1[7] := {193, 232, 268, 288, 296, 298, 309, 360, 372, 450,
		  456, 460, 474, 492, 498, 504, 518, 558, 582, 660,
		  870, 924};
    Table1[8] := {292, 408, 468, 480, 534, 540, 552, 606, 930, 966,
		  990, 1020};
    Table1[9] := {516, 522, 528, 1110, 1140};
    Table1[10] := {600, 840, 1050, 1230, 1290};
    Table1[11] := {};
    Table1[12] := {2310};
    Table1[13] := {1260};
    Table1[14] := {2730};
    Table1[15] := {1470};
    Table1[16] := {};
    Table1[17] := {};
    Table1[18] := {};
    Table1[19] := {1680};
    // We add here a list of discrepancies
    // This is because the formula in [FH99] is slightly better than
    // the one in [HH96] accounting for all the cusps in the quotient
    Table1[3] diff:= {128};
    Table1[5] diff:= {495};
    Table1[6] diff:= {272, 297};
    Table1[7] diff:= {288, 296};
    // !! This is weird - N = 1170 should be appearing in Table 1,
    // but for some reason it does not.
    Table1[12] join:= {1170};
    assert Maximum([c`g : c in curves | c`D eq 1]) eq 19;
    for g in [3..19] do
	genus_g := {c`N : c in curves | (c`D eq 1) and (c`g eq g)};
	assert Table1[g] eq genus_g;
    end for;
    return;
end procedure;

//procedure code_we_ran()
procedure GetHyperellipticCandidates()
    // Find the largest prime we need to consider for the
    // inequality in Proposition 1.
    r := GetLargestPrimeIndex();

    // Find all pairs (D,N) satisfying the inequality of
    // Proposition 1.
    star_curves := FindPairs(r); // time : 1.020

    // I added some code that just
    // focuses on the star quotients X_0^*(D,N)
    
    assert #star_curves eq 2342;

    UpdateGenera(~star_curves); // time : 53.760
    
    VerifyHHTable1(star_curves);

    UpdateByGenus(~star_curves);

    FilterByTrace(~star_curves); // time :
    
    // Create a list of all Atkin-Lehner quotients
    // compute their genera, and store the covering structure.
    
    // For some reason this now takes an insane amount of time
    // Check if the subgroup lattice is inefficient
    curves := GetQuotientsAndGenera(star_curves); // time : 5458.290

    // updating classification from the genera we computed
    UpdateByGenus(~curves);

    // downward closure - if covered by subhyperelliptic, then subhyperelliptic
    DownwardClosure(~curves);

    // Using the fact that if w acts non-trivially ans has more than
    // 4 fixed points on X, then X is non-hyperelliptic
    FilterByALFixedPointsOnQuotient(~curves);

    // upward closure - if covering a non-hyperelliptic, then non-hyperelliptic
    UpwardClosure(~curves);

    // if a genus 3 covers a genus 2 curve, then it is hyperelliptic
    Genus3CoversGenus2(~curves);
    
    DownwardClosure(~curves);

    // Using Proposition 6 from [FH] adapted to the Shimura curve situation
    FilterByComplicatedALFixedPointsOnQuotient(~curves);

    UpwardClosure(~curves);

    // Using trace of Hecke operators to count points and show more curves are
    // non-hyperelliptic
    FilterByTrace(~curves);

    UpwardClosure(~curves);
    
end procedure;

// [FH] Furumoto, Hasegawa, "Hyperelliptic Quotients of Modular Curves X_0(N)"
//
// [HH] Hasegawa, Hashimoto, "Hyperelliptic modular curves X_0^*(N) 
// with square-free levels"
//
// [Ogg] Real points on Shimura Curves
