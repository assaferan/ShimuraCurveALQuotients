// File for determining the hyperelliptic quotients of Shimura curves
// of the form X_0(D,N)

// Committed to Geometrically Hyperelliptic curves

declare verbose ShimuraQuotients, 3;

declare type ShimuraQuot;

declare attributes ShimuraQuot: D, N, W, g, CurveID, CoveredBy, Covers, IsP1, IsEC, IsHyp, IsSubhyp;

import "TraceFormula.m" : TraceFormulaGamma0HeckeAL,
                          TraceFormulaGamma0HeckeALNew;

// D - Discriminant of Quaternion algebra
// N - Level of Eichler order
// W - set of d | DN such that the group generated by w_d,
// the corresponding Atkin-Lehner involutions, is the group we quotient by
// g - Genus of the quotient
// CurveID - a unique identifier
// CoveredBy - CurveIDs of the curves directly covering it
// Covers - CurveIDs of the curves it is directly covering
// IsP1 - f isomorphic to P1 (geom.), g = 0
// IsEC - if elliptic curve (geom.), g = 1
// IsHyp - if hyperelliptic (neither elliptic, nor p1)
// IsSubhyp - if subhyperelliptic (i.e. any of the above)

function IsEqualCurve(crv1, crv2)
    if (crv1`D ne crv2`D) then
    return false;
    end if;
    if (crv1`N ne crv2`N) then
    return false;
    end if;
    if (crv1`W ne crv2`W) then
    return false;
    end if;
    if (crv1`g ne crv2`g) then
    return false;
    end if;
    if (assigned crv1`IsP1) then
    if not assigned crv2`IsP1 then
        return false;
    end if;
    if (crv1`IsP1 ne crv2`IsP1) then
        return false;
    end if;
    end if;
    if (assigned crv1`IsEC) then
    if not assigned crv2`IsEC then
        return false;
    end if;
    if (crv1`IsEC ne crv2`IsEC) then
        return false;
    end if;
    end if;
    if (assigned crv1`IsHyp) then
    if not assigned crv2`IsHyp then
        return false;
    end if;
    if (crv1`IsHyp ne crv2`IsHyp) then
        return false;
    end if;
    end if;
    if (assigned crv1`IsSubhyp) then
    if not assigned crv2`IsSubhyp then
        return false;
    end if;
    if (crv1`IsSubhyp ne crv2`IsSubhyp) then
        return false;
    end if;
    end if;
    return true;
end function;

// Lower and upper bounds for number of points in reduction mod p,
// scaled by 12/p-1, see [HH]

function Omega(n)
    return #PrimeDivisors(n);
end function;

function FirstPrimes(n)
    ps := PrimesUpTo(1+Ceiling(n*(Log(n+1)+Log(Log(n+1)))));
    assert #ps ge n;
    return ps[1..n];
end function;

function LowerBoundD(D)
    return EulerPhi(D)/ 2^Omega(D);
end function;

function LowerBoundN(N)
    ps := PrimeDivisors(N);
    if N eq 1 then
        c_N := 1;
       else
        c_N := N * &*[ 1 + 1/p : p in ps];
    end if;
    return c_N / 2^Omega(N);
end function;

function LowerBound(D, N, p: lb:=false)
    if lb cmpeq false then
        lb := LowerBoundD(D)*LowerBoundN(N);
    end if;
    if D eq 1 then
        h := Maximum([h : h in [ 1, 2, 3, 4, 6, 8, 12, 24 ] | N mod h^2 eq 0]);
        h2 := GCD(h,8); h3 := GCD(h,3);
        cond2 := IsEven(h2) and (N mod h2^2 eq 0) and
             (GCD(h2^2, N div h2^2) eq 1);
        s2 := cond2 select 3/4 else 1;
        cond3 := (h3 eq 3) and Valuation(N, 3) eq 2;
        s3 := cond3 select 2/3 else 1;
        s := s2*s3;
        lb +:= 12*h*s/(p-1);
    end if;
    return lb;
end function;

function UpperBound(p : Geometric := true)
    // We use the fact that the geometric gonality is 2
    // so gonality over Q (hence also over F_p) is at most 4
    gonality := 2;
    /* Not needed in the hyperelliptic case, because of [Poonen, Thm 2.5(i)]
    if Geometric then
    gonality := gonality^2;
    end if;
    */
    return 12*gonality*(1+p^2)/(p-1);
end function;

function MinimalNumberOfALinQuotient(D, N)
    ps := PrimeDivisors(N);
    c_D := EulerPhi(D);
    c_N := N * &*[Rationals() | 1 + 1/p : p in ps];
    p := 2;
    while (N mod p eq 0) do
    p := NextPrime(p);
    end while;
    return Maximum(0,Ceiling(Log(2, (c_D * c_N) / UpperBound(p))));
end function;

procedure VerifyBound(r)
    ps := FirstPrimes(r+1);
    assert LowerBoundN(&*ps[1..r]) gt UpperBound(ps[r+1] :
                         Geometric := false);
    assert LowerBoundD(&*ps[1..r]) gt UpperBound(ps[r+1]);
end procedure;

function GetLargestPrimeIndex()
    p := 1;
    prod := 1;
    LB := 1;
    UB := 1;
    r := -1;
    while (LB le UB) do
    prod *:= p;
    p := NextPrime(p);
    LB := LowerBoundD(prod);
    UB := UpperBound(p);
    r +:= 1;
    end while;
    VerifyBound(r);
    return r;
end function;

function FindMaximalN(r)
    ps := FirstPrimes(r);
    return Floor(UpperBound(ps[r])*2^(r-1));
end function;

// Using https://math.stackexchange.com/questions/301837/is-the-euler-phi-function-bounded-below EEDDIITT -> TODO: Find a reference
function FindMaximalD(r)
    ps := FirstPrimes(r);
    ub := Ceiling(UpperBound(ps[r]));
    C := 2^(r-1)*ub;
    p := 2;
    prev := Infinity();
    bound := Infinity();
    A := p;
    RR := RealField();
    r := 1;
    while (bound le prev) do
    p := NextPrime(p);
    delta := RR!(1 - Log(p-1) / Log(p));
    A *:= p;
    r +:= 1;
    prev := bound;
    bound := Ceiling(A*(C/EulerPhi(A))^(1/(1-delta)));
    // print "bound = ", bound;
    end while;
    return bound; //, r, A;
end function;

// At the moment, we restrict to D and N being coprime
// Find all curves X_0*(D,N) which might be subhyperelliptic
function FindPairs(r : Coprime := true)
    pairs := [];
    // N0 := FindMaximalN(r);
    ps := FirstPrimes(r);
    ub := Ceiling(UpperBound(ps[r]));
    C := 2^(r-1)*ub;
    D0 := FindMaximalD(r);
    // Ds := [D : D in [1..D0] | IsSquarefree(D) and IsEven(Omega(D))];
    Ds := [D : D in [1..D0] | MoebiusMu(D) eq 1];

    // stores LowerBoundN on [1..C]
    lNs := [LowerBoundN(N) : N in [1..C]];
    for D in Ds do
        lD := LowerBoundD(D);
        // print "D = ", D;
        // Nmax := Floor(N0 / EulerPhi(D));
        Nmax := Ceiling(C / EulerPhi(D));
        Ns := [1..Nmax];
        if Coprime then
            Ns := [N : N in Ns | GCD(D,N) eq 1];
        end if;

        for N in Ns do
            /*
            if (N mod 1000 eq 0) then
            print "N =", N;
            end if;
           */
            p := 2;
            while (N mod p eq 0) do
            p := NextPrime(p);
            end while;
            if D ne 1 then
                if lD*lNs[N] le UpperBound(p) then
                    W := {d : d in Divisors(D*N) | GCD(d, (D*N) div d) eq 1};
                    Append(~pairs, rec<CurveQuot | D := D, N := N, W := W >);
                end if;
            else
                if (LowerBound(D, N, p) le UpperBound(p)) then
                    W := {d : d in Divisors(D*N) | GCD(d, (D*N) div d) eq 1};
                    Append(~pairs, rec<CurveQuot | D := D, N := N, W := W >);
                end if;
            end if;
        end for;
    end for;
    for i->pair in pairs do
	pairs[i]`CurveID := i;
    end for;
    return pairs;
end function;

// 2 corresponds to cusps, 3, 4
function NumberOfEllipticPoints(D, N, order)
    if order eq 2 then
    if D eq 1 then
        return &+[EulerPhi(GCD(d, N div d)) : d in Divisors(N)];
    else
        return 0;
    end if;
    end if;
    if order eq 4 then
    Q := 4;
    end if;
    if order eq 3 then
    Q := 9;
    end if;
    if (N mod Q eq 0) then
    return 0;
    end if;
    primesD := PrimeDivisors(D);
    primesN := PrimeDivisors(N);
    e_D := &*[Integers() | 1 - KroneckerSymbol(-order, p) : p in primesD];
    e_N := &*[Integers() | 1 + KroneckerSymbol(-order, p) : p in primesN];
    return e_D * e_N;
end function;

function GenusShimuraCurve(D, N)
    phiD := EulerPhi(D);
    primes := PrimeDivisors(N);
    P1N := Floor(N * &*[Rationals() | 1 + 1/p : p in primes]);
    g := 1 + phiD * P1N / 12;
    e := AssociativeArray();
    for h in [2,3,4] do
	e[h] := NumberOfEllipticPoints(D, N, h);
	g -:= e[h] / h;
    end for;
    assert IsIntegral(g);
    return Floor(g);
end function;

function PsiOgg(p, n)
    if (n eq 1) then
    return 1;
    end if;
    is_prime_power, q, k := IsPrimePower(n);
    if (is_prime_power) then
    return ((q eq p) select Floor(p^k *(1 + 1/p)) else 1);
    end if;
    fac := Factorization(n);
    return &*[Integers() | PsiOgg(p, pe[1]^pe[2]) : pe in fac];
end function;

function LegendreSymbol(R, p)
    f := Conductor(R);
    if (f mod p eq 0) then
    return 1;
    end if;
    ZF := MaximalOrder(R);
    return KroneckerCharacter(Discriminant(ZF))(p);
end function;

// Here R is the quadratic order and
// O is a fixed quaternion Eichler order of level F in
// the quaternion algebra B of discriminant D.
// based on Theorem 2 in [Ogg]
function NuOgg(p, R, D, F)
    if (D mod p eq 0) then
    return 1 - LegendreSymbol(R, p);
    end if;
    if Valuation(F, p) eq 1 then
    return 1 + LegendreSymbol(R, p);
    end if;
    assert Valuation(F, p) ge 2;
    f := Conductor(R);
    ZF := MaximalOrder(R);
    chi := KroneckerCharacter(Discriminant(ZF));
    k := Valuation(f, p);
    K := Valuation(F, p);
    if (K ge 2*(1 + k)) then
    if (chi(p) eq 1) then
        return 2*PsiOgg(p, f);
    end if;
    return 0;
    end if;
    if (K eq 1 + 2*k) then
    if (chi(p) eq 1) then
        return 2*PsiOgg(p, f);
    end if;
    if (chi(p) eq 0) then
        return p^k;
    end if;
    assert chi(p) eq -1;
    return 0;
    end if;
    if (K eq 2*k) then
    return p^(k-1)*(p+1+chi(p));
    end if;
    if (K le 2*k - 1) then
    if IsEven(K) then
        return p^(k div 2) + p^(k div 2 - 1);
    else
        return 2*p^(k div 2);
    end if;
    end if;
    // Should not reach here
    assert false;
end function;


function SquarePart(m)
    fac := Factorization(m);
    prod := 1;
    for f in fac do
        if f[2] ge 2 then
            if IsEven(f[2]) then
                prod *:=  Integers()!(f[1]^(Integers()!f[2]/2));
            else
                prod *:=  Integers()!(f[1]^(Integers()!(f[2]-1)/2));
            end if;
        end if;
    end for;
    return prod;
end function;

function ConstructOrders(m : cached_orders := AssociativeArray())
    //_<x> := PolynomialRing(Integers());
    if m in Keys(cached_orders) then
        return cached_orders[m];
    else
        if (m eq 2) then
            orders := [MaximalOrder(QuadraticField(-1)),
                   MaximalOrder(QuadraticField(-2))];
        elif (m mod 4 eq 3) then
            F<a> := QuadraticField(-m);
            // _, sqrt_minus_m := IsSquare(F!(-m));
            sqm := SquarePart(m);
            sqrt_minus_m:= sqm*a;
            O := MaximalOrder(F);
            alpha := (1 + sqrt_minus_m)/2;
            orders := [sub<O | 1, alpha>, sub<O | 1, 2*alpha>];
            // orders := [EquationOrder(x^2+x+((m+1) div 4)), EquationOrder(x^2+m)];
        else
            F<a> := QuadraticField(-m);
            sqm := SquarePart(m);
            sqrt_minus_m:= sqm*a;
            // _, sqrt_minus_m := IsSquare(F!(-m));
            O := MaximalOrder(F);
            orders := [sub<O | 1, sqrt_minus_m>];
            // orders := [EquationOrder(x^2+m)];
        end if;
        class_nos :=[];
        for R in orders do
            //compute info about orders and store it
            //let's start with just storing the class numbers
            h := PicardNumber(R);
            // h := #PicardGroup(R);
            Append(~class_nos, h);
        end for;
        cached_orders[m] := [* orders, class_nos *];
        return cached_orders[m];
    end if;

end function;

// Quotient by w_m, m divides DN, following [Ogg]

// The number of the fixed points of w_m on X_0(D,N)
function NumFixedPoints(D, N, m :cached_orders := false)
    e := 0;
    pair := ConstructOrders(m :cached_orders:=cached_orders);
    orders := pair[1];
    class_nos := pair[2];
    for i->R in orders do
        // h := PicardNumber(R);
        h := class_nos[i];
        // Using formula (4) in [Ogg]
        prod := &*[Integers() |
              NuOgg(p, R, D, N) : p in PrimeDivisors(D*N) | m mod p ne 0];
        e +:= h*prod;
    end for;
    if (D eq 1) and (m eq 4) then
        M := N div 4;
        num_fixed_cusps := &+[Integers() | EulerPhi(GCD(d, M div d)) : d in Divisors(M)];
        e +:= num_fixed_cusps;
    end if;
    return e;
end function;

function GenusShimuraCurveQuotientSingleAL(D, N, m :cached_orders := cached_orders)
    e := NumFixedPoints(D, N, m :cached_orders := cached_orders);
    g_big := GenusShimuraCurve(D, N);
    g := (g_big+1)/2 - e/4;
    assert IsIntegral(g);
    return Floor(g);
end function;

function GenusShimuraCurveQuotient(D, N, als :cached_orders := cached_orders)
    total_e := 0;
    for al in als do
    assert GCD(al, (D*N) div al) eq 1;
    if (al ne 1) then
        total_e +:= NumFixedPoints(D, N, al : cached_orders := cached_orders);
    end if;
    end for;
    if #als eq 1 then
    s := 0;
    else
    is_prime_power, two, s := IsPrimePower(#als);
    assert is_prime_power and (two eq 2);
    end if;
    g_big := GenusShimuraCurve(D, N);
    g := 1 + (g_big - 1)/2^s - total_e/2^(s+1);
    assert IsIntegral(g);
    return Floor(g);
end function;

function exp_to_Q(e, N, ps)
    ZZ := Integers();
    e := Eltseq(e);
    P := Parent(e[1]);
    return &*[ZZ | ps[i]^Valuation(N,ps[i]) : i in [1..#ps] | e[i] eq P!1];
end function;

function al_mul(w, m, ND)
    ps := PrimeDivisors(ND);
    // ps := PrimeDivisors(w*m);
    wvals := Vector(Integers(), [Valuation(w, p) : p in ps]);
    mvals := Vector(Integers(), [Valuation(m, p) : p in ps]);
    // wmvals := mvals + wvals;
    wmvals := Vector(Integers(), [0 : p in ps]);
    for i in [1..#ps] do
        if wvals[i] eq 0 then
            wmvals[i] := mvals[i];
        elif mvals[i] eq 0 then
            wmvals[i] := wvals[i];
        else
            wmvals[i] := 0;
        end if;
    end for;
    wm := &*[ps[i]^(wmvals[i]) : i in [1..#ps]];
    return wm;
end function;

function ReduchedEchelonMatrixIterator(k, n : K := FiniteField(2))
    // copied from sage code
    /*An iterator over `(k,n)` reduced echelon matrices over the finite field `K`.

    INPUT:

    - ``K`` -- a finite field

    - ``k`` -- number of rows (or the size of the subspace)

    - ``n`` -- number of columns (or the dimension of the ambient space)*/
    if n lt k then
        error "echelon matrix with fewer rows than columns i.e. not full rank are not implemented";
    end if;
    matrices := [];

    one := K!1;
    Klist := [x : x in K];
    //select pivot columns
    for pivots in Subsets({1..n},k) do
        sqpivots := SetToSequence(pivots);
        m0 := KMatrixSpace(K,k,n)!ZeroMatrix(K,k,n);
        free_positions := [];
        for i in [1..k] do
            m0[i,sqpivots[i]] := one;
            for j in [sqpivots[i]+1..n] do
                if j notin sqpivots then
                    Append(~free_positions,<i,j>);
                end if;
            end for;
        end for;
    //fill in the rest of the entries not determined by pivot columns/ RREF
        num_free_pos := #free_positions;
        for v in CartesianPower(Klist, num_free_pos) do
            for i in [1..num_free_pos] do
                    m0[free_positions[i][1], free_positions[i][2]] := v[i];
            end for;
            Append(~matrices, m0);
        end for;
     end for;

    return matrices;
end function;



// Returns a sequence of tuples,
// containing the divisors in the group, the indices of maximal subgroups
// and the indices of minimal overgroups


function MaxSubgroups(m, sl);
    r := #Rows(m);
    if r eq 0 then
        return {Integers()|};
    else
        all_mats :=  &cat[[* x : x in r *] : r in sl];
        subgps := {};
        for n in sl[r] do //rank r-1 things
            if RowSpace(n) subset RowSpace(m) then
                i := Index(all_mats, n);
                Include(~subgps, i);
            end if;
        end for;
        return subgps;
    end if;

end function;

function MinOvergps(m, sl);
    r := #Rows(m);
    all_mats :=  &cat[[* x : x in r *] : r in sl];
    if r eq #sl - 1 then
        return {Integers()|};
    else
        subgps := {};
        for n in sl[r+2] do
            if RowSpace(m) subset RowSpace(n) then
                i := Index(all_mats, n);
                Include(~subgps, i);
            end if;
        end for;
        return subgps;
    end if;
end function;

function AllALsFromGens(Ws, ND)
    allws := {Integers()|};
    S := Subsets(Ws);
    for s in S do
        if #s eq 0 then
            Include(~allws, 1);
        else
            prod := 1;
            for w in s do
                prod := al_mul(w,prod, ND);
            end for;
            Include(~allws, prod);
        end if;
    end for;
    return allws;
end function;

function ALSubgroups(N)
    ZZ := Integers();
    Qs_in_grp := AssociativeArray();
    ps := PrimeDivisors(N);
    Qs := [];
    subgp_lattice := [* *];
    for r in [0..#ps] do
        ms := ReduchedEchelonMatrixIterator(r,#ps);
        Append(~subgp_lattice, ms);
    end for;

    for rkgp in subgp_lattice do
        for m in rkgp do
            if #Rows(m) eq 0 then
                grp := {Integers()|};
            else
                grp := {Integers()|exp_to_Q(e,N,ps) : e in Rows(m)};
            end if;
            // print grp;
            // Include(~Qs, grp);
            grp := AllALsFromGens(grp, N);
            // print "generates", grp;
            Append(~Qs, <grp, MaxSubgroups(m, subgp_lattice), MinOvergps(m,subgp_lattice)>);
        end for;
    end for;

    return Qs;
end function;


procedure UpdateGenera(~curves : cached_orders := cached_orders)
    for i->c in curves do
	curves[i]`g := GenusShimuraCurveQuotient(c`D, c`N, c`W : cached_orders := cached_orders);
    end for;
    return;
end procedure;

function GetQuotientsAndGenera(curves: cached_orders := cached_orders)
    quots := [];
    for i->c in curves do
        min_num := MinimalNumberOfALinQuotient(c`D, c`N);
        al_subs := ALSubgroups(c`D*c`N);
        allowed_idxs := [j : j in [1..#al_subs] | #al_subs[j][1] ge 2^min_num];
        update_idxs := func < S | {Index(allowed_idxs, idx)
                           : idx in S | idx in allowed_idxs}>;
        allowed_subs := [<al_subs[j][1],
                        update_idxs(al_subs[j][2]),
                        update_idxs(al_subs[j][3])>
                        : j in allowed_idxs];
        cur_sz := #quots;
        for j->S in allowed_subs do
            als := S[1];
            g := GenusShimuraCurveQuotient(c`D, c`N, als : cached_orders := cached_orders);
            quot := rec<CurveQuot | D := c`D, N := c`N, W := als,
                        g := g, CurveID := cur_sz + j,
                        CoveredBy := {cur_sz + idx : idx in S[2]},
                        Covers := {cur_sz + idx : idx in S[3]}>;
            Append(~quots, quot);
        end for;
        if (i mod 100 eq 0) then
            print "i = ", i, "/", #curves;
        end if;
    end for;
    return quots;
end function;

/*
function sum_n_powers(a_p, p, n)
    if n eq 0 then
    return 2;
    end if;
    if n eq 1 then
    return a_p;
    end if;
    return a_p*sum_n_powers(a_p, p, n-1) - p*sum_n_powers(a_p, p, n-2);
end function;
*/

// Can work faster if we first compute all the traces (half the work)
function sum_n_powers(mfs, p, n, BV)
    assert n ge 1;
    assert Level(mfs) mod p ne 0;
    T_p_n := HeckeOperator(mfs, p^n);
    T_p_n := ChangeRing(T_p_n, Rationals());
    T_p_n := Solution(BV, BV*T_p_n);
    if n eq 1 then
    return Trace(T_p_n);
    end if;
    T_p_n_2 := HeckeOperator(mfs, p^(n-2));
    T_p_n_2 := ChangeRing(T_p_n_2, Rationals());
    T_p_n_2 := Solution(BV, BV*T_p_n_2);
    return Trace(T_p_n - p*T_p_n_2);
end function;

// At the moment only works on the whole space S_2(N)
function sum_n_powers_trace_formula(N, W, p, n)
    t_p_n := 1/#W*&+[TraceFormulaGamma0HeckeAL(N, 2, p^n, w) : w in W];
    if n eq 1 then
    return t_p_n;
    end if;
    t_p_n_2 := 1/#W*&+[TraceFormulaGamma0HeckeAL(N, 2, p^(n-2), w) : w in W];
    return t_p_n - p*t_p_n_2;
end function;

function TraceDNew(D,N,k,n,Q)
    t := 0;
    for dN in Divisors(N) do
        N_prime := D*N div dN;
        ds := get_ds(D*N, Q, N_prime, n);
        for d in ds do
            n_p := n_prime(d, D*N, Q, N_prime, n);
            d_p := d_prime(d, D*N, Q, N_prime);
            dd_p := dd_prime(d, D*N, Q, N_prime, n);
            Q_p := Q_prime(D*N, Q, N_prime);
            // Should always be trivial as n is coprime to D*N
            // term := GCD(d_p, n);
            // term *:= MoebiusMu(dd_p);
            // t_d := TraceFormulaGamma0HeckeALNew(N_prime, k, n, GCD(Q, N_prime));
            // t +:= t_d * #Divisors(d);
            t +:= TraceFormulaGamma0HeckeALNew(N_prime, k, n, Q_p);
        end for;
    end for;
    return t;
end function;

function TraceDNewALFixed(D,N,k,n,W)
    return 1/#W*&+[TraceDNew(D, N, k, n, w) : w in W];
end function;

function sum_n_powers_trace_formula(D, N, W, p, n)
    t_p_n := TraceDNewALFixed(D,N,2,p^n,W);
    if n eq 1 then
    return t_p_n;
    end if;
    t_p_n_2 := TraceDNewALFixed(D,N,2,p^(n-2),W);
    return t_p_n - p*t_p_n_2;
end function;

// Returns false if X is not subhyperelliptic
// If returns true we don't know (compare point counts)

function CheckHeckeTrace(X)
    // g := X[4];
    assert X`g ge 3;
    // N := X[2];
    // D := X[1];
    // ws := [w : w in X[3] | w ne 1];
    ws := [w : w in X`W | w ne 1];
    mfs := CuspidalSubspace(ModularSymbols(X`D*X`N,2,1));
    primes := PrimeDivisors(X`D);
    for p in primes do
	mfs := NewSubspace(mfs, p);
    end for;
    als := [AtkinLehnerOperator(mfs,w) : w in ws];
    V := VectorSpace(Rationals(), Dimension(mfs));
    for al in als do
	V := V meet Kernel(al-1);
    end for;
    BV := BasisMatrix(V);
    ps := [p : p in PrimesUpTo(4*X`g^2) | X`D*X`N mod p ne 0];
    for p in ps do
        v_max := Floor(Log(p,4*X`g^2));
        tps := AssociativeArray([-1..v_max]);
        tps[-1] := 0;
        for v in [1..v_max] do
            tps[v] := TraceDNewALFixed(X`D, X`N, 2, p^v, X`W);
        end for;
        if (v_max gt 1) then
            tps[0] := TraceDNewALFixed(X`D, X`N, 2, 1, X`W);
        end if;
        for v in [1..v_max] do
            trace_frob_n := tps[v] - p*tps[v-2];
            num_pts := p^v  + 1 - trace_frob_n;
            if (num_pts gt 2*(1+p^v)) then
                print "p, v = ", p, v;
                return false;
            end if;
        end for;
    end for;
    return true;
end function;

procedure FilterByTrace(~curve_list)
    lut := AssociativeArray();
    for i->X in curve_list do
	if assigned X`IsSubhyp then
            continue;
	end if;
	print "i = ", i;
	if not CheckHeckeTrace(X) then
            curve_list[i]`IsSubhyp := false;
            curve_list[i]`IsHyp := false;
	end if;
    end for;
    return;
end procedure;

function CountFixedPointsOnQuotient(w, c : cached_orders := AssociativeArray())
    return (1/#c`W) * &+[NumFixedPoints(c`D, c`N, al_mul(w, m, c`N*c`D) : cached_orders := cached_orders) : m in c`W];
end function;

// If X_0*(N) is not P1 and is subhyperelliptic
// (so it is either elliptic or hyperelliptic)
// then any AL involution on X = X_0(N)/W is non-hyperelliptic
// and if X is hyperelliptic, has atmost four fixed points.
// Test returns false if X is non-hyperelliptic
// If true, X might be hyperelliptic
function TestALFixedPointsOnQuotient(X : cached_orders := AssociativeArray())
    // D, N, W, g := Explode(c);
    DN := X`D*X`N;
    ws := [d : d in Divisors(DN) | d notin X`W and (GCD(d, DN div d) eq 1)];
    for d in ws do
    fix := CountFixedPointsOnQuotient(d, X : cached_orders := cached_orders);
    if IsEven(X`g) and fix gt 2 then
        return false;
    elif IsOdd(X`g) and fix gt 4 then
        return false;
    end if;
    end for;
    return true;
end function;

procedure FilterByALFixedPointsOnQuotient(~curves : cached_orders := AssociativeArray())
    for lc->c in curves do
    if (assigned c`IsSubhyp) and c`IsSubhyp then
        continue;
    end if;
    // if testALFixedPointsOnQuotient(c) then
        // Include(~passed_test, c);
    if not TestALFixedPointsOnQuotient(c : cached_orders := cached_orders) then
        curves[lc]`is_subhyp := false;
    end if;
    // lc +:= 1;
    if (lc mod 100 eq 0) then
        print "lc = ", lc;
    end if;
    end for;
    return;
end procedure;

// implementing Proposition 6 of [FH]
// returns the W for which X_0(D,N)/W is not hyperelliptic
function TestComplicatedALFixedPointsOnQuotient(D,N)
    cond_2 := [N2 : N2 in Divisors(N) | ClassNumber(-4*N2) mod 3 eq 0];
    // print "cond_2 = ", cond_2;
    cond_1 := [N2 : N2 in cond_2 | (N2 mod 4 ne 3) or
				   ((N2 mod 8 eq 3) and IsEven(N)) or
				   ((N2 mod 8 eq 7) and IsEven(D))];
    // print "cond_1 = ", cond_1;
    num_fixed := [NumFixedPoints(D, N, N2) : N2 in cond_1];
    good_idxs := [i : i in [1..#num_fixed] | (num_fixed[i] ne 0) and
		  (num_fixed[i] mod 3 eq 0) and
		  (PrimeDivisors(num_fixed[i]) subset [2,3]) ];
    N2s := [cond_1[i] : i in good_idxs];
    // print "N2s = ", N2s;
    nfixed := [num_fixed[i] : i in good_idxs];
    omega := Omega(D*N);
    Ws := ALSubgroups(D*N);
    // !! TODO - Could reuse the data we already have
    Ws := [W[1] : W in Ws | GenusShimuraCurveQuotient(D, N, W[1]) ge 3];
    non_hyp := {};
    for i->N2 in N2s do
	r := omega - Valuation(nfixed[i], 2);
	Ws_N2 := [W : W in Ws | (#W eq 2^(omega-r)) and (N2 notin W)];
/*
	if (N2 eq 195) then
	    print "N2 = ", 195;
	    print "Ws = ", Ws;
	end if;
*/
	for W in Ws do
	    is_non_hyp := false;
	    N1s := [N1 : N1 in Divisors(N) | (N1 notin W) and (N1 ne N2)];
	    N1s := [N1 : N1 in N1s | NumFixedPoints(D, N, N1) eq 2^(omega-r)];
/*
	    if (N2 eq 195) and ({6, 10, 26} subset W) then
		print "N1s = ", N1s;
	    end if;
*/
	    for N1 in N1s do
		a := AssociativeArray();
		for w in W do
		    a[al_mul(N1, w,D*N)] := w;
		end for;
		/*
		if (N2 eq 195) and ({6, 10, 26} subset W) then
		    print "N1 = ", N1;
		    for k in Keys(a) do
			print "a[", k, "] = ", a[k];
		    end for;
		end if;
*/
		for w in W do
		    N_prime := al_mul(N2, w, D*N);
		    //if (N2 eq 195) and ({6, 10, 26} subset W) then
			// print "w = ", w;
			// print "N2 * w = ", N_prime;
		    //end if;
		    if IsDefined(a, N_prime) then
			/*
			print "N_prime = ", N_prime;
			print "N_double_prime = ", a[N_prime];
			print "N_triple_prime = ", w;
			print "h(-4N_1) = ", ClassNumber(-4*N1);
			print "h(-4N_2) = ", ClassNumber(-4*N2);
		       */
			Include(~non_hyp, W);
			Ws := [WW : WW in Ws | WW ne W]; 
			is_non_hyp := true;
			break;
		    end if;
		end for;
		if is_non_hyp then
		    break;
		end if;
	    end for;
	end for;
    end for;
    return non_hyp;
end function;

procedure UpdateByGenus(~curves)
    for i in [1..#curves] do
    if (curves[i]`g eq 0) then
        curves[i]`IsP1 := true;
        curves[i]`IsEC := false;
        curves[i]`IsHyp := false;
        // check the ones with hyperelliptic AL involution
        if assigned curves[i]`CoveredBy then
        for cover in curves[i]`CoveredBy do
            curves[cover]`IsSubhyp := true;
            if (curves[cover]`g ge 2) then
            curves[cover]`IsHyp := true;
            end if;
        end for;
        end if;
    end if;
    if (curves[i]`g eq 1) then
        curves[i]`IsEC := true;
        curves[i]`IsHyp := false;
    end if;
    if (curves[i]`g eq 2) then
        curves[i]`IsHyp := true;
    end if;
    if (curves[i]`g le 2) then
        curves[i]`IsSubhyp := true;
    end if;
    end for;
    return;
end procedure;

procedure FilterByComplicatedALFixedPointsOnQuotient(~curves)
    DN_pairs := {<c`D, c`N> : c in curves | not assigned c`IsSubhyp};
    DN_pairs := [pair : pair in DN_pairs];

    lut := AssociativeArray();
    for i in [1..#curves] do
    c := curves[i];
    lut[<c`D, c`N, c`W>] := i;
    end for;

    for lc->DN in DN_pairs do
    D, N := Explode(DN);
    Ws := TestComplicatedALFixedPointsOnQuotient(D, N);
    for W in Ws do
        if not IsDefined(lut, <D,N,W>) then
        continue;
        end if;
        curves[lut[<D,N,W>]]`IsSubhyp := false;
        if (curves[lut[<D,N,W>]]`g ge 2) then
        curves[lut[<D,N,W>]]`IsHyp := false;
        end if;
    end for;
    if (lc mod 100 eq 0) then
        print "lc = ", lc;
    end if;
    end for;
    return;
end procedure;

procedure DownwardClosure(~curves)
    for c in curves do
    if (assigned c`IsSubhyp) and c`IsSubhyp then
        for covered in c`Covers do
        curves[covered]`IsSubhyp := true;
        end for;
    end if;
    end for;
    return;
end procedure;

procedure UpwardClosure(~curves)
    for c in curves do
    if (assigned c`IsSubhyp) and (not c`IsSubhyp) then
        for cover in c`CoveredBy do
        curves[cover]`IsSubhyp := false;
        end for;
    end if;
    end for;
    return;
end procedure;

procedure Genus3CoversGenus2(~curves)
    for c in curves do
    if c`g eq 2 then
        for cover in c`CoveredBy do
        if curves[cover]`g eq 3 then
            curves[cover]`IsSubhyp := true;
            curves[cover]`IsHyp := true;
        end if;
        end for;
    end if;
    end for;
    return;
end procedure;

procedure VerifyHHTable1(curves)
    Table1 := AssociativeArray([3..19]);
    Table1[3] := {97, 109, 113, 127, 128, 136, 139, 144, 149, 151,
          152, 162, 164, 169, 171, 175, 178, 179, 183, 185,
          187, 189, 194, 196, 203, 207, 217, 234, 236, 240,
          245, 246, 248, 249, 252, 258, 270, 282, 290, 294,
          295, 303, 310, 312, 315, 318, 329, 348, 420, 429,
          430, 455, 462, 476, 510};
    Table1[4] := {137, 148, 160, 172, 173, 176, 199, 200, 201, 202,
          214, 219, 224, 225, 228, 242, 247, 254, 259, 260,
          261, 262, 264, 267, 273, 275, 280, 300, 305, 306,
          308, 319, 321, 322, 335, 341, 342, 345, 350, 354,
          355, 366, 370, 374, 385, 399, 426, 434, 483, 546,
          570};
    Table1[5] := {157, 181, 192, 208, 212, 216, 218, 226, 235, 237,
          250, 253, 278, 279, 302, 323, 364, 371, 377, 378,
          391, 396, 402, 406, 410, 414, 418, 435, 438, 440,
          442, 444, 465, 494, 495, 595, 630, 714, 770, 798};
    Table1[6] := {163, 197, 211, 244, 265, 272, 274, 291, 297, 301,
          325, 336, 340, 470, 506, 561, 564, 690, 780, 858};
    Table1[7] := {193, 232, 268, 288, 296, 298, 309, 360, 372, 450,
          456, 460, 474, 492, 498, 504, 518, 558, 582, 660,
          870, 924};
    Table1[8] := {292, 408, 468, 480, 534, 540, 552, 606, 930, 966,
          990, 1020};
    Table1[9] := {516, 522, 528, 1110, 1140};
    Table1[10] := {600, 840, 1050, 1230, 1290};
    Table1[11] := {};
    Table1[12] := {2310};
    Table1[13] := {1260};
    Table1[14] := {2730};
    Table1[15] := {1470};
    Table1[16] := {};
    Table1[17] := {};
    Table1[18] := {};
    Table1[19] := {1680};
    // We add here a list of discrepancies
    // This is because the formula in [FH99] is slightly better than
    // the one in [HH96] accounting for all the cusps in the quotient
    Table1[3] diff:= {128};
    Table1[5] diff:= {495};
    Table1[6] diff:= {272, 297};
    Table1[7] diff:= {288, 296};
    // !! This is weird - N = 1170 should be appearing in Table 1,
    // but for some reason it does not.
    Table1[12] join:= {1170};
    assert Maximum([c`g : c in curves | c`D eq 1]) eq 19;
    for g in [3..19] do
    genus_g := {c`N : c in curves | (c`D eq 1) and (c`g eq g)};
    assert Table1[g] eq genus_g;
    end for;
    return;
end procedure;


procedure UpdateIsoStatus(~c1, ~c2)

    if assigned(c1`is_hyp) and not assigned(c2`is_hyp) then
        c2`is_hyp := c1`is_hyp;
        print "found pair";
        print N, WNs;
        print M, WMs;
    elif assigned(c2`is_hyp) and not assigned(c1`is_hyp) then
        c1`is_hyp := c2`is_hyp;
        print "found pair";
        print N, WNs;
        print M, WMs;
    elif assigned(c1`is_hyp) and assigned(c2`is_hyp) then
        assert assigned(c1`is_hyp) eq assigned(c2`is_hyp);
    end if;
function GetHHTable2()
    Table2 := [[] : g in [1..19]];
    Table2[3] := [ 127, 136, 144, 152, 162, 164, 171, 175, 183, 185,
           194, 196, 207, 217, 234, 240, 246, 252, 258, 270,
           282, 290, 294, 310, 312, 315, 318, 348, 420, 462,
           476, 510 ];
    Table2[4] := [ 160, 176, 264, 280, 300, 306, 322, 342, 345, 370,
           546, 570 ];
    Table2[5] := [ 216, 279, 396, 630, 714 ];
    Table2[6] := [ 336, 690 ];
    Table2[7] := [ 360, 450 ];
    Table2[10] := [840];
    Table2[12] := [2310];
    // This seems to be removed by considering p = 11, v = 2. Check!
    // Table2[19] := [1680];
    return Table2;
end function;

function GetModularByGenus(curves)
    g_max := Maximum([X`g : X in curves]);
    by_genus := [[X`N : X in curves | X`D eq 1 and
                      not assigned X`IsSubhyp and
                      X`g eq g] : g in [1..g_max]];
    return by_genus;
end function;

procedure VerifyHHTable2(curves)
    Table2 := GetHHTable2();
    by_genus := GetModularByGenus(curves);
    assert Table2 eq by_genus;
    return;
end procedure;

procedure VerifyHHProposition1(curves)
    Table2 := GetHHTable2();
    by_genus := GetModularByGenus(curves);
    Table2[3] := [N : N in Table2[3] | N ne 194];
    Table2[4] := [N : N in Table2[4] | N ne 546];
    assert Table2 eq by_genus;
    return;
end procedure;

// Apply the observation from [HH96] Proposition 1,
// that if X_0^*(D, pN) and X_0^*(D, N) have the same genus,
// they will be isomorphic in characteristic p
procedure HHProposition1(~curves)
    lut_D := AssociativeArray();
    lut_DN := AssociativeArray();
    for X in curves do
    lut_DN[<X`D, X`N>] := X`CurveID;
    if not IsDefined(lut_D, X`D) then
        lut_D[X`D] := [];
    end if;
    lut_D[X`D] := Append(lut_D[X`D], X`N);
    end for;
    for i->X in curves do
    if (assigned X`IsSubhyp) and (not X`IsSubhyp) then
        Ns := lut_D[X`D];
        ps := [N div X`N : N in Ns | (N mod X`N eq 0) and
                     IsPrime(N div X`N)];
        for p in ps do
        if IsDefined(lut_DN, <X`D, p*X`N>) then
            other := lut_DN[<X`D, p*X`N>];
            if X`g eq curves[other]`g then
            curves[other]`IsSubhyp := false;
            curves[other]`IsHyp := false;
            end if;
        end if;
        end for;
    end if;
    end for;
    return;
end procedure;

// Get a hyperelliptic curve from q-expansions
function IsHyperelliptic(qexps, prec)
    R<q> := Universe(qexps);
    K := BaseRing(R);
    fs := [f + O(q^prec) : f in qexps];
    g := #fs;
    T, E := EchelonForm(Matrix([&cat[Eltseq(x)
                     : x in AbsEltseq(f)] : f in fs]));
    fs := [&+[E[j][i]*fs[i] : i in [1..g]] : j in [1..g]];
    x := fs[g-1] / fs[g];
    y := q * Derivative(x) / fs[g];
    mons := [x^i : i in [0..2*g+2]] cat [-y^2];
    denom := q^(-(2*g+2)*Valuation(x));
    f_mons := [denom*m + O(q^AbsolutePrecision(y)) : m in mons];
    ker := Kernel(Matrix([AbsEltseq(f : FixedLength) : f in f_mons]));
    if (Dimension(ker) eq 0) then
    return false, _;
    end if;
    if Dimension(ker) gt 1 then
    error "Too many relations, not enough precision!";
    end if;
    ker_b := Basis(ker)[1];
    ker_b /:= -ker_b[2*g+4];
    R<x> := PolynomialRing(K);
    poly := &+[ker_b[i+1]*x^i : i in [0..2*g+2]];
    X := HyperellipticCurve(-poly);
    return true, X, fs;
end function;

end procedure;

procedure UpdateByIsomorphisms(curves)

    lut := AssociativeArray();
    for i in [1..#curves] do
        c := curves[i];
        lut[<c`D, c`N, c`W>] := i;
    end for;

    for i in [1..#curves] do
        curve := curves[i];
        M := curve`N;
        WMs := curve`W;
        D := curve`D;
        if IsEven(M) and GCD(2, M div 2) eq 1 then
            N := 2*M;
            WNs := Include(WMs, 4);
            curve2 := lut[<D, N, WNs>];
            UpdateIsoStatus(curve1, curve2);
        end if;
	
        function eps(Ni)
            if (Ni eq 1 mod 3) or ((Ni mod 9 eq 0) and (Ni div 9) mod 9 eq 1) then
                return 1;
            else
                return 0;
            end if;
        end function;

        if M mod 9 eq 0 and GCD(9, M div 9 eq 1) then
            WNs := {};
            for Ni in WMs do
                e:= eps(Ni);
                if e ne 0 then
                    Include(~WNs, al_mul(Ni, 9));
                else
                    Include(~WNs, Ni);
                end if;
            end for;
        end if;
        curve2 := lut[<D, M, WNs>];
        if assigned(curve`is_hyp) and not assigned(curve2`is_hyp) then
            curve2`is_hyp := curve`is_hyp;
            print "found pair";
            print N, WNs;
            print M, WMs;
        elif assigned(curve2`is_hyp) and not assigned(curve`is_hyp) then
            curve`is_hyp := curve2`is_hyp;
            print "found pair";
            print N, WNs;
            print M, WMs;
        elif assigned(curve`is_hyp) and assigned(curve2`is_hyp) then
            assert assigned(curve`is_hyp) eq assigned(curve2`is_hyp);
        else
            continue;
        end if;
    end for;
end procedure;
// Although this is not a canonical model over Q,
// it still yields a geometrical model over C,
// so we can use the q-expansions to check
// now using Eran's magma hack to allow for
// D-new modular forms where D is not a prime
// Returns whether the curve is geometrically hyperelliptic or not
function qExpansionCheck(X)
    assert X`g ge 3;
    assert X`D eq 1; // At the moment this only makes sense for modular curves
    ws := [w : w in X`W | w ne 1];
    mfs := NewSubspace(CuspForms(X`D*X`N,2), X`D);
    mfs := BaseChange(mfs, Rationals());
    als := [AtkinLehnerOperator(mfs,w) : w in ws];
    V := VectorSpace(mfs);
    for al in als do
    V := V meet Kernel(al-1);
    end for;
    assert X`g eq Dimension(V);
    BV := BasisMatrix(V);
    prec := 4*X`g^2+8*X`g-20+1;
    qexps := [qExpansion(f, prec) : f in Basis(mfs)];
    Rq<q> := Universe(qexps);
    coeff_mat := Matrix([AbsEltseq(qexp) : qexp in qexps]);
    qexps_V := [Rq!Eltseq(r) : r in Rows(BV*coeff_mat)];
    return IsHyperelliptic(qexps_V, prec);
end function;

procedure Filter_qExpansion(~curves)
    for i->X in curves do
	if not assigned X`IsSubhyp then
            curves[i]`IsHyp := qExpansionCheck(X);
            curves[i]`IsSubhyp := curves[i]`IsHyp;
	end if;
    end for;
end procedure;

//procedure code_we_ran()
procedure GetHyperellipticCandidates()
    // Find the largest prime we need to consider for the
    // inequality in Proposition 1.
    r := GetLargestPrimeIndex();

    // Find all pairs (D,N) satisfying the inequality of
    // Proposition 1.
    time star_curves := FindPairs(r); // time : 1.980

    // I added some code that just
    // focuses on the star quotients X_0^*(D,N)

    assert #star_curves eq 2342;

    cached_orders := AssociativeArray();

    time UpdateGenera(~star_curves: cached_orders := cached_orders); // time: 12

    VerifyHHTable1(star_curves);


    UpdateByGenus(~star_curves);

    FilterByTrace(~star_curves); // time :

    VerifyHHTable2(star_curves);

    // Create a list of all Atkin-Lehner quotients
    // compute their genera, and store the covering structure.

    // writing to a file, in case we would like to load it directly
    Write("star_curves_point_count.dat", star_curves : Overwrite);

    // testing that reading the file works
    read_curves := eval Read("star_curves_point_count.dat");
    assert #read_curves eq #star_curves;
    assert &and[IsEqualCurve(read_curves[j], star_curves[j]) :
        j in [1..#star_curves]];

    // Applying Proposition 1 from [HH96]
    // verifying that we get the right thing for modular curves
    HHProposition1(~star_curves);
    VerifyHHProposition1(star_curves);

    // Create a list of all Atkin-Lehner quotients
    // compute their genera, and store the covering structure.

    time curves := GetQuotientsAndGenera(star_curves: cached_orders := cached_orders); // 148.660

    // updating classification from the genera we computed
    UpdateByGenus(~curves);

    // downward closure - if covered by subhyperelliptic, then subhyperelliptic
    DownwardClosure(~curves);

    // Using the fact that if w acts non-trivially ans has more than
    // 4 fixed points on X, then X is non-hyperelliptic
    FilterByALFixedPointsOnQuotient(~curves : cached_orders := cached_orders);

    // upward closure - if covering a non-hyperelliptic, then non-hyperelliptic
    UpwardClosure(~curves);

    // if a genus 3 covers a genus 2 curve, then it is hyperelliptic
    Genus3CoversGenus2(~curves);

    DownwardClosure(~curves);

    // Using Proposition 6 from [FH] adapted to the Shimura curve situation
    FilterByComplicatedALFixedPointsOnQuotient(~curves);

    UpwardClosure(~curves);

    // Using trace of Hecke operators to count points and show more curves are
    // non-hyperelliptic
    FilterByTrace(~curves);

    UpwardClosure(~curves);

end procedure;

// [FH] Furumoto, Hasegawa, "Hyperelliptic Quotients of Modular Curves X_0(N)"
//
// [HH] Hasegawa, Hashimoto, "Hyperelliptic modular curves X_0^*(N)
// with square-free levels"
//
// [Ogg] Real points on Shimura Curves
